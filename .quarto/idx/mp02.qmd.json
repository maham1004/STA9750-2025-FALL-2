{"title":"STA 9750 — Mini-Project 02","markdown":{"yaml":{"title":"STA 9750 — Mini-Project 02","author":"Maham Hassan","date":"October 30, 2025","format":{"html":{"code-fold":true,"toc":true}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nHousing affordability has become a huge challenge facing cities across the country, the supply of housing just cannot keep up with the demand. A lot of the debate comes down to two clashing philosophies: YIMBY (“Yes In My Backyard”), which argues that cities should make it easier to build housing, and NIMBY (“Not In My Backyard”), which pushes back against new development out of fear that it will change neighborhood character, lead to gentrification, or hurt property values. It’s a controversial topic because both sides claim to be protecting their communities. \n\nIn this project, we will dig into Census, ACS and BLS data to see which metro areas are  embracing the YIMBY approach and which ones are effectively blocking growth. We will build rent burden and housing growth metrics, track trends across hundreds of CBSAs, and identify a handful of metros that stand out as YIMBY success stories. \n\n\n```{r, results='hide', message=FALSE, warning=FALSE}\ntidycensus::census_api_key(\"aa14982ecd4bb502eb657c121f3d02e9b1c45cee\", install = FALSE)\n\ngetwd()\nlist.files(\"data\", recursive = TRUE)\n\n\nif(!dir.exists(file.path(\"data\", \"mp02\"))){\n    dir.create(file.path(\"data\", \"mp02\"), showWarnings=FALSE, recursive=TRUE)\n}\n\nlibrary <- function(pkg){\n    ## Mask base::library() to automatically install packages if needed\n    ## Masking is important here so downlit picks up packages and links\n    ## to documentation\n    pkg <- as.character(substitute(pkg))\n    options(repos = c(CRAN = \"https://cloud.r-project.org\"))\n    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)\n    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))\n}\n\nlibrary(tidyverse)\nlibrary(glue)\nlibrary(readxl)\nlibrary(tidycensus)\n\nget_acs_all_years <- function(variable, geography=\"cbsa\",\n                              start_year=2009, end_year=2023){\n    fname <- glue(\"{variable}_{geography}_{start_year}_{end_year}.csv\")\n    fname <- file.path(\"data\", \"mp02\", fname)\n    \nif(!file.exists(fname)){\n        YEARS <- seq(start_year, end_year)\n        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)\n        \n        ALL_DATA <- map(YEARS, function(yy){\n            tidycensus::get_acs(geography, variable, year=yy, survey=\"acs1\") |>\n                mutate(year=yy) |>\n                select(-moe, -variable) |>\n                rename(!!variable := estimate)\n        }) |> bind_rows()\n        \n        write_csv(ALL_DATA, fname)\n    }\n    \n    read_csv(fname, show_col_types=FALSE)\n}\n\n# Household income (12 month)\nINCOME <- get_acs_all_years(\"B19013_001\") |>\n    rename(household_income = B19013_001)\n\n# Monthly rent\nRENT <- get_acs_all_years(\"B25064_001\") |>\n    rename(monthly_rent = B25064_001)\n\n# Total population\nPOPULATION <- get_acs_all_years(\"B01003_001\") |>\n    rename(population = B01003_001)\n\n# Total number of households\nHOUSEHOLDS <- get_acs_all_years(\"B11001_001\") |>\n    rename(households = B11001_001)\nget_building_permits <- function(start_year = 2009, end_year = 2023){\n    fname <- glue(\"housing_units_{start_year}_{end_year}.csv\")\n    fname <- file.path(\"data\", \"mp02\", fname)\n    \n    if(!file.exists(fname)){\n        HISTORICAL_YEARS <- seq(start_year, 2018)\n        \n        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){\n            historical_url <- glue(\"https://www.census.gov/construction/bps/txt/tb3u{yy}.txt\")\n                \n            LINES <- readLines(historical_url)[-c(1:11)]\n\n            CBSA_LINES <- str_detect(LINES, \"^[[:digit:]]\")\n            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))\n\n            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), \"[[:digit:]]\")\n            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))\n            \n            data_frame(CBSA = CBSA,\n                       new_housing_units_permitted = PERMITS, \n                       year = yy)\n        }) |> bind_rows()\n        \n        CURRENT_YEARS <- seq(2019, end_year)\n        \n        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){\n            current_url <- glue(\"https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls\")\n            \n            temp <- tempfile()\n            \n            download.file(current_url, destfile = temp, mode=\"wb\")\n            \n            fallback <- function(.f1, .f2){\n                function(...){\n                    tryCatch(.f1(...), \n                             error=function(e) .f2(...))\n                }\n            }\n            \n            reader <- fallback(read_xlsx, read_xls)\n            \n            reader(temp, skip=5) |>\n                na.omit() |>\n                select(CBSA, Total) |>\n                mutate(year = yy) |>\n                rename(new_housing_units_permitted = Total)\n        }) |> bind_rows()\n        \n        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)\n        \n        write_csv(ALL_DATA, fname)\n        \n    }\n    \n    read_csv(fname, show_col_types=FALSE)\n}\n\nPERMITS <- get_building_permits()\n\nlibrary(httr2)\nlibrary(rvest)\nget_bls_industry_codes <- function(){\n    fname <- file.path(\"data\", \"mp02\", \"bls_industry_codes.csv\")\n    library(dplyr)\n    library(tidyr)\n    library(readr)\n    \n    if(!file.exists(fname)){\n        \n        resp <- request(\"https://www.bls.gov\") |> \n            req_url_path(\"cew\", \"classifications\", \"industry\", \"industry-titles.htm\") |>\n            req_headers(`User-Agent` = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0\") |> \n            req_error(is_error = \\(resp) FALSE) |>\n            req_perform()\n        \n        resp_check_status(resp)\n        \n        naics_table <- resp_body_html(resp) |>\n            html_element(\"#naics_titles\") |> \n            html_table() |>\n            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), \"NAICS\"))) |>\n            select(-`Industry Title`) |>\n            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>\n            filter(!is.na(depth))\n        \n        # These were looked up manually on bls.gov after finding \n        # they were presented as ranges. Since there are only three\n        # it was easier to manually handle than to special-case everything else\n        naics_missing <- tibble::tribble(\n            ~Code, ~title, ~depth, \n            \"31\", \"Manufacturing\", 1,\n            \"32\", \"Manufacturing\", 1,\n            \"33\", \"Manufacturing\", 1,\n            \"44\", \"Retail\", 1, \n            \"45\", \"Retail\", 1,\n            \"48\", \"Transportation and Warehousing\", 1, \n            \"49\", \"Transportation and Warehousing\", 1\n        )\n        \n        naics_table <- bind_rows(naics_table, naics_missing)\n        \n        naics_table <- naics_table |> \n            filter(depth == 4) |> \n            rename(level4_title=title) |> \n            mutate(level1_code = str_sub(Code, end=2), \n                   level2_code = str_sub(Code, end=3), \n                   level3_code = str_sub(Code, end=4)) |>\n            left_join(naics_table, join_by(level1_code == Code)) |>\n            rename(level1_title=title) |>\n            left_join(naics_table, join_by(level2_code == Code)) |>\n            rename(level2_title=title) |>\n            left_join(naics_table, join_by(level3_code == Code)) |>\n            rename(level3_title=title) |>\n            select(-starts_with(\"depth\")) |>\n            rename(level4_code = Code) |>\n            select(level1_title, level2_title, level3_title, level4_title, \n                   level1_code,  level2_code,  level3_code,  level4_code) |>\n            drop_na() |>\n            mutate(across(contains(\"code\"), as.integer))\n        \n        write_csv(naics_table, fname)\n    }\n    \n    read_csv(fname, show_col_types=FALSE)\n}\n\nINDUSTRY_CODES <- get_bls_industry_codes()\nlibrary(httr2)\nlibrary(rvest)\nget_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){\n    fname <- glue(\"bls_qcew_{start_year}_{end_year}.csv.gz\")\n    fname <- file.path(\"data\", \"mp02\", fname)\n    \n    YEARS <- seq(start_year, end_year)\n    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS\n    \n    if(!file.exists(fname)){\n        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){\n            fname_inner <- file.path(\"data\", \"mp02\", glue(\"{yy}_qcew_annual_singlefile.zip\"))\n            \n            if(!file.exists(fname_inner)){\n                request(\"https://www.bls.gov\") |> \n                    req_url_path(\"cew\", \"data\", \"files\", yy, \"csv\",\n                                 glue(\"{yy}_annual_singlefile.zip\")) |>\n                    req_headers(`User-Agent` = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0\") |> \n                    req_retry(max_tries=5) |>\n                    req_perform(fname_inner)\n            }\n            \n            if(file.info(fname_inner)$size < 755e5){\n                warning(sQuote(fname_inner), \"appears corrupted. Please delete and retry this step.\")\n            }\n            \n            read_csv(fname_inner, \n                     show_col_types=FALSE) |> \n                mutate(YEAR = yy) |>\n                select(area_fips, \n                       industry_code, \n                       annual_avg_emplvl, \n                       total_annual_wages, \n                       YEAR) |>\n                filter(nchar(industry_code) <= 5, \n                       str_starts(area_fips, \"C\")) |>\n                filter(str_detect(industry_code, \"-\", negate=TRUE)) |>\n                mutate(FIPS = area_fips, \n                       INDUSTRY = as.integer(industry_code), \n                       EMPLOYMENT = as.integer(annual_avg_emplvl), \n                       TOTAL_WAGES = total_annual_wages) |>\n                select(-area_fips, \n                       -industry_code, \n                       -annual_avg_emplvl, \n                       -total_annual_wages) |>\n                # 10 is a special value: \"all industries\" , so omit\n                filter(INDUSTRY != 10) |> \n                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)\n        })) |> bind_rows()\n        \n        write_csv(ALL_DATA, fname)\n    }\n    \n    ALL_DATA <- read_csv(fname, show_col_types=FALSE)\n    \n    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)\n    \n    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)\n    \n    if(length(YEARS_DIFF) > 0){\n        stop(\"Download failed for the following years: \", YEARS_DIFF, \n             \". Please delete intermediate files and try again.\")\n    }\n    \n    ALL_DATA\n}\n\nWAGES <- get_bls_qcew_annual_averages()\n```\n## Initial Data Exploration\n\n1. Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?\n\nThe **Houston-Sugarland-Baytown** area in Texas has permitted the largest number of housing units from 2010 to 2019 during which they allowed 482,075 units to be built.\n\n```{r, results='hide', message=FALSE, warning=FALSE}\nlibrary(tidyverse)\n\n# Load the housing data\nhousing <- read_csv(\"data/mp02/housing_units_2009_2023.csv\")\n\n# Check the first few rows and structure\nglimpse(housing)\n\n#| include: false\n# Filter housing data for 2010-2019\nhousing_2010_2019 <- housing |>\n  filter(year >= 2010 & year <= 2019)\n\n# Quick check\nglimpse(housing_2010_2019)\n\n#| include: false\n# Sum new housing units per CBSA for the decade\nhousing_summed <- housing_2010_2019 |>\n  group_by(CBSA) |>\n  summarise(total_units = sum(new_housing_units_permitted, na.rm = TRUE)) |>\n  arrange(desc(total_units))\n\n# Look at top CBSA totals\nhead(housing_summed, 10)\n\n#| echo: true\n# Sum new housing units per CBSA for the decade\nhousing_summed <- housing_2010_2019 |>\n  group_by(CBSA) |>\n  summarise(total_units = sum(new_housing_units_permitted, na.rm = TRUE)) |>\n  arrange(desc(total_units))\n\n# Load CBSA metadata\ncbsa_meta <- read_csv(\"data/mp02/B01003_001_cbsa_2009_2023.csv\")\n\n# Join summed housing with CBSA names using GEOID\nhousing_named <- housing_summed |>\n  left_join(cbsa_meta, by = c(\"CBSA\" = \"GEOID\"))\n\n# Show the CBSA with the largest total units\nhousing_named |> slice(1)\n\n#| echo: true\nlibrary(DT)\n\n# Get the CBSA with the largest total units\ntop_cbsa <- housing_named |>\nrename(Population = B01003_001) |>\nselect(CBSA, NAME, total_units, Population, year) |>\nslice(1)\n```\n```{r}\n# Display as clean data table\ndatatable(\ntop_cbsa,\ncolnames = c(\"CBSA\", \"Name\", \"Total Units\", \"Population\", \"Year\"),\noptions = list(dom = 't', autoWidth = TRUE),\nrownames = FALSE\n) |>\nformatCurrency(columns = c(\"total_units\", \"Population\"), currency = \"\", digits = 0) #commas in numbers \n \n\n\n \n\n# \n```  \n\n\n2. In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?\n\nHint: There is a Covid-19 data artifact here that may trip you up if you do not look at your answer closely.\n\nAlbuquerque permitted the most new housing in 2021. However, this year was an anomaly likely due to COVID-19 related slowdowns in the year prior. Other than 2021, the highest number of permits were issued in **2022** when **2,852** new housing units were permitted to be built. \n\n```{r}\n# Make sure PERMITS exists\n\npermits <- get_building_permits()\nlibrary(tidyverse)\nlibrary(DT)\n\n# Filter for Albuquerque, NM (CBSA 10740) and show top 10 years\n\nalbuquerque_top10 <- permits |>\nfilter(CBSA == 10740) |>\narrange(desc(new_housing_units_permitted)) |>\nslice_head(n = 10)\n\n# Display as a clean interactive table\n\ndatatable(\nalbuquerque_top10,\ncolnames = c(\"CBSA\", \"New Units Permitted\", \"Year\"),\noptions = list(dom = 't', autoWidth = TRUE),\nrownames = FALSE\n) |>\nformatCurrency(columns = \"new_housing_units_permitted\", currency = \"\", digits = 0)\n\n#\n```\n\n3. Which state (not CBSA) had the highest average individual income in 2015? To answer this question, you will need to first compute the total income per CBSA by multiplying the average household income by the number of households, and then sum total income and total population across all CBSAs in a state. With these numbers, you can answer this question.\n\nThough not technically a state, **Washington D.C**. had the highest average individual income. \n\n\n```{r}\nlibrary(dplyr)\nlibrary(stringr)\n\n# 1. Merge the 2015 data sets\nacs_2015 <- INCOME |> \n  filter(year == 2015) |>\n  left_join(HOUSEHOLDS |> filter(year == 2015), by = c(\"GEOID\", \"NAME\", \"year\")) |>\n  left_join(POPULATION |> filter(year == 2015),  by = c(\"GEOID\", \"NAME\", \"year\"))\n\n# 2. Compute total income per CBSA\nacs_2015 <- acs_2015 |>\n  mutate(total_income = household_income * households)\n\n# 3. Extract the principal state abbreviation from the CBSA name\nacs_2015 <- acs_2015 |>\n  mutate(state = str_extract(NAME, \", (.{2})\", group = 1))\n\n# 4. Aggregate to the state level\nstate_summary <- acs_2015 |>\n  group_by(state) |>\n  summarise(\n    total_income = sum(total_income, na.rm = TRUE),\n    total_population = sum(population, na.rm = TRUE)\n  ) |>\n  mutate(avg_individual_income = total_income / total_population)\n\n# 5. Add full state names\nstate_df <- data.frame(\n  abb  = c(state.abb, \"DC\", \"PR\"),\n  name = c(state.name, \"District of Columbia\", \"Puerto Rico\")\n)\n\nstate_summary <- state_summary |>\n  left_join(state_df, by = c(\"state\" = \"abb\")) |>\n  arrange(desc(avg_individual_income))\n\n\n```\n```{r}\n#Display data table\n\ndatatable(\n  state_summary |> \n    arrange(desc(avg_individual_income)) |> \n    rename(\n      State = state,\n      `Total Income` = total_income,\n      Population = total_population,\n      `Avg. Individual Income` = avg_individual_income\n    ),\n  options = list(\n    pageLength = 10,    # show 10 rows per page\n    autoWidth = TRUE\n  ),\n  rownames = FALSE\n) |>\n  formatCurrency(\n    columns = c(\"Total Income\", \"Population\", \"Avg. Individual Income\"),\n    currency = \"\", \n    digits = 0\n  )\n\n\n#\n```\n\n\n4. Data scientists and business analysts are recorded under NAICS code 5182. What is the last year in which the NYC CBSA had the most data scientists in the country? In recent, the San Francisco CBSA has had the most data scientists.\n\n **2015** was the last time that New York had the most data scientists in the country; that year they employed **18,922** data scientists. \n\n\n```{r, results='hide', message=FALSE, warning=FALSE}\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(DT)\n\n# Create a new CBSA join key in WAGES\nWAGES <- WAGES |>\n  mutate(\n    CBSA_join = as.double(paste0(str_remove(FIPS, \"C\"), \"0\"))\n  )\n\n# Filter for data scientists (NAICS 5182)\ndata_sci <- WAGES |>\n  filter(INDUSTRY == 5182) |>\n  select(CBSA_join, EMPLOYMENT, YEAR)\n\n# Join to get CBSA names\ndata_sci_named <- data_sci |>\n  inner_join(cbsa_meta |> select(GEOID, NAME), by = c(\"CBSA_join\" = \"GEOID\"))\n\n# Find which CBSA had the most per year\ntop_data_sci_each_year <- data_sci_named |>\n  group_by(YEAR) |>\n  slice_max(order_by = EMPLOYMENT, n = 1, with_ties = FALSE) |>\n  arrange(YEAR)\n```\n```{r}\n# Display as a nice interactive table\ndatatable(\n  top_data_sci_each_year |>\n    rename(\n      Year = YEAR,\n      CBSA = NAME,\n      Employment = EMPLOYMENT\n    ),\n  options = list(pageLength = 10, autoWidth = TRUE),\n  rownames = FALSE\n) |>\n  formatCurrency(columns = \"Employment\", currency = \"\", digits = 0)\n\n#\n```\n\n5. What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?\n\nIn **2021** the fraction of total wages earned by people in the finance industry peaked at **15.87%**\n\n```{r, results='hide', message=FALSE, warning=FALSE}\n### Q5. What fraction of total wages in the NYC CBSA \n### was earned by people employed in the Finance & Insurance industries (NAICS 52)?\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(scales)\n\n# 1. Compute total wages for all industries in NYC CBSA (C3562)\ntotal_nyc_wages <- WAGES |>\n  filter(FIPS == \"C3562\") |>\n  group_by(YEAR) |>\n  summarise(total_wages = sum(TOTAL_WAGES, na.rm = TRUE))\n\n# 2. Compute total wages for Finance & Insurance (NAICS 52xx)\nfinance_insurance_nyc <- WAGES |>\n  filter(FIPS == \"C3562\", str_starts(as.character(INDUSTRY), \"52\")) |>\n  group_by(YEAR) |>\n  summarise(finance_insurance_wages = sum(TOTAL_WAGES, na.rm = TRUE))\n\n# 3. Combine and compute percent of total\nfinance_insurance_percent <- finance_insurance_nyc |>\n  inner_join(total_nyc_wages, by = \"YEAR\") |>\n  mutate(\n    percent_of_total = (finance_insurance_wages / total_wages) * 100\n  ) |>\n  arrange(desc(percent_of_total)) |>\n  select(YEAR, total_wages, finance_insurance_wages, percent_of_total)\n\n# 4. Print the full table nicely formatted\nprint(\n  finance_insurance_percent,\n  n = nrow(finance_insurance_percent)\n)\n\n# 5. Identify the peak year and percent\npeak_row <- finance_insurance_percent |> slice(1)\npeak_year <- peak_row$YEAR\npeak_share <- percent(peak_row$percent_of_total / 100, accuracy = 0.01)\n```\n```{r}\n# 6. Display concise summary\ncat(\"\\n\")\ncat(\"Peak Year:\", peak_year, \"\\n\")\ncat(\"Finance & Insurance Share of Total Wages:\", peak_share, \"\\n\")\n\n\n```\n\n## Data Visualization\n```{r}\n#relationship between Monthly Rent and Average Household Income per CBSA in 2009\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(scales)\n\n# 1. Filter and join data for 2009\nrent_income_2009 <- RENT |>\n  filter(year == 2009) |>\n  inner_join(\n    INCOME |>\n      filter(year == 2009),\n    by = \"GEOID\"\n  ) |>\n  rename(\n    monthly_rent = monthly_rent,\n    household_income = household_income\n  ) |>\n  left_join(cbsa_meta |> select(GEOID, NAME), by = \"GEOID\")\n\n# 2. Fit linear model to get R²\nmodel <- lm(monthly_rent ~ household_income, data = rent_income_2009)\nr2_value <- summary(model)$r.squared\n\n# 3. Create scatter plot with R² annotation\nggplot(rent_income_2009, aes(x = household_income, y = monthly_rent)) +\n  geom_point(alpha = 0.6, color = \"steelblue\") +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"darkred\", linetype = \"dashed\") +\n  scale_x_continuous(labels = label_comma()) +\n  scale_y_continuous(labels = label_comma()) +\n  annotate(\n    \"text\",\n    x = Inf, y = -Inf,\n    label = paste0(\"R² = \", round(r2_value, 3)),\n    hjust = 1.1, vjust = -1.1,\n    size = 5,\n    color = \"black\"\n  ) +\n  labs(\n    title = \"Monthly Rent vs. Average Household Income per CBSA (2009)\",\n    subtitle = \"Each point represents one CBSA\",\n    x = \"Average Household Income ($)\",\n    y = \"Average Monthly Rent ($)\",\n    caption = \"Source: ACS 1-Year Estimates (2009)\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5)\n  )\n\n```\nThere is a correlation between rent and household income in 2009. The R-squared value is nearly 0.6, indicating a fairly strong positive correlation between the two. That being said, there is a fair amount deviation from the linear model. \n\n```{r}\n# Health Care & Social Assistance vs. Total Employment (NAICS 62) small multiples plot\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(broom)\n\n# 1) Total employment per CBSA per year\ntotal_emp <- WAGES |>\n  filter(YEAR >= 2013, YEAR <= 2023, YEAR != 2020) |>\n  group_by(FIPS, YEAR) |>\n  summarise(total_employment = sum(as.numeric(EMPLOYMENT), na.rm = TRUE), .groups = \"drop\")\n\n# 2) Health care employment (NAICS 62xx)\nhealth_emp <- WAGES |>\n  filter(YEAR >= 2013, YEAR <= 2023, YEAR != 2020,\n         str_starts(as.character(INDUSTRY), \"62\")) |>\n  group_by(FIPS, YEAR) |>\n  summarise(health_employment = sum(as.numeric(EMPLOYMENT), na.rm = TRUE), .groups = \"drop\")\n\n# 3) Join and compute R² for each year\nemp_combined <- total_emp |>\n  inner_join(health_emp, by = c(\"FIPS\", \"YEAR\"))\n\nr2_by_year <- emp_combined |>\n  group_by(YEAR) |>\n  summarise(\n    r2 = summary(lm(health_employment ~ total_employment))$r.squared,\n    .groups = \"drop\"\n  )\n\n# 4) Plot — clean, professional look\nggplot(emp_combined, aes(x = total_employment, y = health_employment)) +\n  geom_point(alpha = 0.45, size = 0.8, color = \"seagreen4\") +\n  geom_smooth(method = \"lm\", se = FALSE, linetype = \"dashed\", color = \"firebrick3\") +\n  facet_wrap(~ YEAR, ncol = 5, scales = \"fixed\") +\n  # compact axis labels (e.g., 200K, 1M)\n  scale_x_continuous(labels = label_number(scale_cut = cut_short_scale())) +\n  scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +\n  labs(\n    title = \"Health Care Employment vs. Total Employment Across CBSAs\",\n    subtitle = \"Small multiples show evolution by year \",\n    x = \"Total Employment \",\n    y = \"Health Care & Social Assistance Employment \",\n    caption = \"Source: BLS QCEW Annual Averages (excludes 2020)\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5),\n    strip.text = element_text(face = \"bold\"),\n    axis.text.x = element_text(size = 8),\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_line(color = \"grey90\")\n  ) \n  # Annotate R² per facet\n \n```\n\nThis plot shows the correlation between healthcare employment and total employment and how it has changed over the years. Based on the data, the strong linear correlation has been virtually unchanged; the s-squared fluctuating only about 0.01 over time. \n\n\n```{r}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(stringr)\n\n# Combine and compute household size\nhousehold_size <- HOUSEHOLDS |>\n  select(GEOID, NAME, households, year) |>\n  left_join(\n    POPULATION |> select(GEOID, population, year),\n    by = c(\"GEOID\", \"year\")\n  ) |>\n  mutate(avg_household_size = population / households)\n\n# Label NYC and LA dynamically (regex-safe)\nhousehold_size <- household_size |>\n  mutate(highlight = case_when(\n    str_detect(NAME, regex(\"New York\", ignore_case = TRUE)) ~ \"New York\",\n    str_detect(NAME, regex(\"Los Angeles\", ignore_case = TRUE)) ~ \"Los Angeles\",\n    TRUE ~ \"Other CBSAs\"\n  ))\n\n# Plot\nggplot(household_size, aes(x = year, y = avg_household_size, group = NAME)) +\n  geom_line(aes(color = highlight), alpha = 0.8, linewidth = 0.6) +\n  scale_color_manual(\n    values = c(\n      \"New York\" = \"steelblue\",\n      \"Los Angeles\" = \"darkorange\",\n      \"Other CBSAs\" = \"grey80\"\n    )\n  ) +\n  labs(\n    title = \"Time vs. Average Household Size\",\n    subtitle = \"New York and Los Angeles highlighted\",\n    x = \"Year\",\n    y = \"Average Household Size\",\n    color = \"CBSA\",\n    caption = \"Source: ACS 1-Year Estimates (excluding 2020)\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5)\n  )\n```\n\nThough jumbled, this plot is showing us the average household size and how it has been changing over the years. Each line represents a different CBSA. The blue and orange lines are highlighted to show NYC and LA. The graph is showing a downward trend, particularly in large cities like L.A. and NYC. \n\n\n## Building Indices of Housing Affordability and Housing Stock Growth\n\n### Rent Burden Table \n\n- Rent to income ratio: annual rent/ annual income\n- Rent burden index: we will use the 2009 as the baseline rent to income ratio and calculate the relative rent burden for the subsequent years using this value.\n- 2009 represents 100%, anything above will mean that the rent burden has increased, anything below 100% will mean that the burden has decreased relative to 2009. \n\n\n\n\n\n\n```{r}\n##Task 4\nlibrary(dplyr)\n\n# 1. Merge INCOME and RENT\nrent_burden <- INCOME |>\n  select(GEOID, NAME, year, household_income) |>\n  left_join(\n    RENT |> select(GEOID, year, monthly_rent),\n    by = c(\"GEOID\", \"year\")\n  ) |>\n  mutate(\n    # raw rent burden = annual rent / annual income\n    rent_to_income = (12 * monthly_rent) / household_income\n  ) |>\n  filter(is.finite(rent_to_income))\n\n# 2. Compute the baseline (national average rent burden in 2009)\nbaseline_2009 <- rent_burden |>\n  filter(year == 2009) |>\n  summarise(baseline = mean(rent_to_income, na.rm = TRUE)) |>\n  pull(baseline)\n\n# 3. Create standardized measures\nrent_burden <- rent_burden |>\n  mutate(\n    rent_burden_relative = rent_to_income / baseline_2009,  # multiple of 2009 burden\n    rent_burden_index = rent_burden_relative * 100          # percent of baseline\n  )\n\n\n```\n```{r}\nlibrary(DT)\nlibrary(dplyr)\n\n# NYC table\nnyc_rent_burden <- rent_burden |>\n  filter(NAME == \"New York-Newark-Jersey City, NY-NJ-PA Metro Area\") |>\n  arrange(year) |>\n  select(\n    year,\n    rent_to_income,\n    rent_burden_index\n  )\n\ndatatable(\n  nyc_rent_burden,\n  colnames = c(\"Year\", \"Rent-to-Income (%)\", \"Rent Burden Index (%)\"),\n  caption = htmltools::tags$caption(\n    style = '\n      caption-side: top;\n      text-align: center;\n      font-weight: bold;\n      color: black;\n      font-size: 18px;\n    ',\n    \"New York Metro Area — Rent Burden Over a Ten Year Period\"\n  ),\n  options = list(pageLength = 10, autoWidth = TRUE),\n  rownames = FALSE\n) |>\n\n  formatPercentage(columns = \"rent_to_income\", digits = 1) |>\n    formatRound(columns = \"rent_burden_index\", digits = 1)\n  \n\n\n```\n\n```{r}\n#Scatterplot\nnyc_plot_data <- rent_burden |>\n  filter(NAME == \"New York-Newark-Jersey City, NY-NJ-PA Metro Area\") |>\n  arrange(year)\n\nnyc_plot_data$year <- as.factor(nyc_plot_data$year)\n\nggplot(nyc_plot_data, aes(x = year, y = rent_burden_index, group = 1)) +\n  geom_point(size = 2, color = \"steelblue\") +\n  geom_line(color = \"steelblue\", linewidth = 1) +\n  labs(\n    title = \"NYC Rent Burden Index Over Time\",\n    subtitle = \"Standardized so 100 = national average rent burden in 2009\",\n    x = \"Year\",\n    y = \"Rent Burden Index (2009 = 100)\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n\n```\nThis plot is showing the changes in rent burden in NYC from 2013 to 2023 in reference to 2009. Notice that the rent burden has fluctuated with no real patten over the past decade. \n\n```{r}\n#Comparing metro areas rent burdens\nlibrary(dplyr)\nlibrary(DT)\n\n# Identify latest year\nlatest_year <- max(rent_burden$year)\n\n# Compute rankings\nrent_burden_ranked <- rent_burden |>\n  filter(year == latest_year) |>\n  arrange(desc(rent_burden_index)) |>\n  select(NAME, year, rent_burden_index, rent_to_income)\n\n# Top + bottom 10\nhighest_10 <- rent_burden_ranked |> slice_head(n = 10)\nlowest_10  <- rent_burden_ranked |> slice_tail(n = 10)\n#make highest burden datatable\ndatatable(\n  highest_10,\n  caption = htmltools::tags$caption(\n    style = '\n      caption-side: top;\n      text-align: center;\n      font-weight: 900;\n      color: black;\n      font-size: 20px;\n    ',\n    paste0(\"Top 10 Highest Rent Burden Metros in \", latest_year)\n  ),\n  rownames = FALSE\n) |>\n  formatPercentage(\"rent_to_income\", digits = 1) |>\n  formatRound(\"rent_burden_index\", digits = 1)\n\n#Lowest burden\ndatatable(\n  lowest_10,\n  caption = htmltools::tags$caption(\n    style = '\n      caption-side: top;\n      text-align: center;\n      font-weight: 900;\n      color: black;\n      font-size: 20px;\n    ',\n    paste0(\"Top 10 Lowest Rent Burden Metros in \", latest_year)\n  ),\n  rownames = FALSE\n) |>\n  formatPercentage(\"rent_to_income\", digits = 1) |>\n  formatRound(\"rent_burden_index\", digits = 1)\n\n#scatterplot\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(scales)\n\n# Pick latest available year\nlatest_year <- max(rent_burden$year, na.rm = TRUE)\n\n# Filter for that year\nrb_latest <- rent_burden |>\n  filter(year == latest_year)\n\n# Identify high/low groups\nn_high <- 10\nn_low  <- 10\n\nhigh_ids <- rb_latest |> slice_max(rent_burden_index, n = n_high) |> pull(GEOID)\nlow_ids  <- rb_latest |> slice_min(rent_burden_index, n = n_low) |> pull(GEOID)\n\n# Classification\nrb_latest <- rb_latest |>\n  mutate(\n    group = case_when(\n      GEOID %in% high_ids ~ \"10 Most Rent Burdened\",\n      GEOID %in% low_ids  ~ \"10 Least Rent Burdened\",\n      TRUE ~ \"Other\"\n    )\n  )\n\n# Scatter plot\nggplot(rb_latest, aes(x = household_income, y = rent_burden_index)) +\n  geom_point(aes(color = group), size = 3, alpha = 0.8) +\n  \n\n  scale_x_continuous(labels = label_comma()) +\n  scale_y_continuous(labels = label_comma()) +\n\n  scale_color_manual(\n    values = c(\n      \"10 Most Rent Burdened\" = \"red\",\n      \"10 Least Rent Burdened\" = \"green4\",\n      \"Other\" = \"gray70\"\n    )\n  ) +\n  \n  labs(\n    title = paste0(\"Highest vs. Lowest Rent Burden Metros (\", latest_year, \")\"),\n    subtitle = \"\",\n    x = \"Average Household Income ($)\",\n    y = \"Rent Burden Index\",\n    color = \"\"\n  ) +\n  \n  theme_minimal(base_size = 14) +\n  theme(\n    plot.title = element_text(face = \"bold\", color = \"black\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5),\n    legend.position = \"bottom\",\n    legend.direction = \"horizontal\",\n    legend.box = \"horizontal\",\n    legend.spacing.x = unit(0.5, \"cm\"),\n    legend.title = element_text(size = 12, face = \"bold\"),\n    legend.text = element_text(size = 12)\n  )\n\n\n```\n## Housing Growth\n\nWe will now identify the most building friendly metro areas using two methods.\n\nFirst, we will look at the instantaneous housing growth by measuring how much they build right now given their size. To do this we will measure annual permits per 10,000 people. 2014 is our baseline for the intensity index.\n\nSecond, we evaluate whether metros are building enough given how fast they are growing. To do this, we measure each metro’s population growth over a fixed 5-year window. Then we relate current annual permits to that 5-year population increase, giving us permits per new resident. We again use the 2014 national mean as a baseline to form the growth index since it is the first 5 year window in our data.\n\n\nFinally, we combine these two pieces into a composite measure that reflects both how much a metro builds per capita and how well it keeps up with its own population growth. This composite score helps us identify metros that consistently build at strong levels across both dimensions.\n\n\n\n\n```{r results='asis'}\n\n# task 5 \n#join together the POPULATION and PERMITS tables. Using this data, construct a suitable measure of housing growth: that is, how many new housing units are permitted in a CBSA, relative to both the current number of residents and the overall population growth of that CBSA. Because this metric takes into account growth patterns, it should depend on a fixed lookback-window of 5 years used to estimate population growth.\n\n# Housing Growth\n\nlibrary(dplyr)\nlibrary(DT)\nlibrary(scales)\nlibrary(stringr)\n\n# helper to shorten metro names to first three words\nshort_name3 <- function(x) {\n  sapply(strsplit(x, \" \"), function(y) paste(head(y, 3), collapse = \" \"))\n}\n\n# join POPULATION + PERMITS\npop_housing <- POPULATION %>%\n  select(GEOID, NAME, year, population) %>%\n  left_join(\n    PERMITS %>%\n      rename(\n        GEOID = CBSA,\n        permits = new_housing_units_permitted\n      ),\n    by = c(\"GEOID\", \"year\")\n  )\n\n# compute 5 year population growth within each metro\npop_housing <- pop_housing %>%\n  arrange(GEOID, year) %>%\n  group_by(GEOID) %>%\n  mutate(\n    pop_lag5 = lag(population, 5),\n    pop_growth_5yr = population - pop_lag5\n  ) %>%\n  ungroup()\n\n# instantaneous measure permits per 10k residents and index baseline 2014 mean = 100\npop_housing <- pop_housing %>%\n  mutate(permits_per_10k = (permits / population) * 10000)\n\nbaseline_intensity_2014 <- pop_housing %>%\n  filter(year == 2014) %>%\n  summarise(mean_10k = mean(permits_per_10k, na.rm = TRUE)) %>%\n  pull(mean_10k)\n\npop_housing <- pop_housing %>%\n  mutate(intensity_index = (permits_per_10k / baseline_intensity_2014) * 100)\n\n# rate based measure permits relative to 5 year population growth and index baseline 2014 mean = 100\npop_housing <- pop_housing %>%\n  mutate(permits_per_growth = permits / pop_growth_5yr)\n\nbaseline_growth_2014 <- pop_housing %>%\n  filter(year == 2014) %>%\n  summarise(mean_growth = mean(permits_per_growth, na.rm = TRUE)) %>%\n  pull(mean_growth)\n\npop_housing <- pop_housing %>%\n  mutate(growth_index = (permits_per_growth / baseline_growth_2014) * 100)\n\n# composite score no weights simple average of the two indices\npop_housing <- pop_housing %>%\n  mutate(composite_score = (intensity_index + growth_index) / 2)\n\n# choose most recent year available for tables\nlatest_year <- max(pop_housing$year, na.rm = TRUE)\n\n# build instantaneous table top 10 and bottom 10 by permits per 10k in latest year\ninst_tbl <- pop_housing %>%\n  filter(year == latest_year, is.finite(permits_per_10k)) %>%\n  mutate(\n    Category = if_else(intensity_index >= 100, \"HIGH\", \"LOW\"),\n    `Metro Area` = short_name3(NAME)\n  ) %>%\n  select(\n    Category,\n    `Metro Area`,\n    Population = population,\n    `Annual Permits` = permits,\n    `Permits per 10k` = permits_per_10k,\n    `Intensity Index` = intensity_index\n  )\n\ninst_high <- inst_tbl %>%\n  filter(Category == \"HIGH\") %>%\n  arrange(desc(`Permits per 10k`)) %>%\n  slice_head(n = 10)\n\ninst_low <- inst_tbl %>%\n  filter(Category == \"LOW\") %>%\n  arrange(`Permits per 10k`) %>%\n  slice_head(n = 10)\n\ninst_final <- bind_rows(inst_high, inst_low)\n\ndatatable(\n  inst_final %>%\n    mutate(\n      Population = comma(Population),\n      `Annual Permits` = comma(`Annual Permits`),\n      `Permits per 10k` = round(`Permits per 10k`, 2),\n      `Intensity Index` = round(`Intensity Index`, 1)\n    ),\n  rownames = FALSE,\n  options = list(\n    dom = 't',\n    pageLength = 20,\n    autoWidth = TRUE\n  ),\n   caption = htmltools::tags$caption(\n    style = 'caption-side: top; text-align: left; margin-bottom: 10px;',\n    htmltools::tags$div(\n      style = 'font-size: 16pt; font-weight: bold;',\n      paste0(\"Permits Per Capita In \", latest_year)\n    )\n  )\n)\n\n# build growth adjusted table top 10 and bottom 10 by permits per growth in latest year\ngrowth_tbl <- pop_housing %>%\n  filter(year == latest_year, is.finite(permits_per_growth)) %>%\n  mutate(\n    Category = if_else(growth_index >= 100, \"HIGH\", \"LOW\"),\n    `Metro Area` = short_name3(NAME)\n  ) %>%\n  select(\n    Category,\n    `Metro Area`,\n    `5 Year Population Growth` = pop_growth_5yr,\n    `Annual Permits` = permits,\n    `Permits per Growth` = permits_per_growth,\n    `Growth Index` = growth_index\n  )\n\ngrowth_high <- growth_tbl %>%\n  filter(Category == \"HIGH\") %>%\n  arrange(desc(`Permits per Growth`)) %>%\n  slice_head(n = 10)\n\ngrowth_low <- growth_tbl %>%\n  filter(Category == \"LOW\") %>%\n  arrange(`Permits per Growth`) %>%\n  slice_head(n = 10)\n\ngrowth_final <- bind_rows(growth_high, growth_low)\n\ndatatable(\n  growth_final %>%\n    mutate(\n      `5 Year Population Growth` = comma(`5 Year Population Growth`),\n      `Annual Permits` = comma(`Annual Permits`),\n      `Permits per Growth` = round(`Permits per Growth`, 3),\n      `Growth Index` = round(`Growth Index`, 1)\n    ),\n  rownames = FALSE,\n  options = list(\n    dom = 't',\n    pageLength = 20,\n    autoWidth = TRUE\n  ),\n  caption = htmltools::tags$caption(\n    style = 'caption-side: top; text-align: left; margin-bottom: 10px;',\n    htmltools::tags$div(\n      style = 'font-size: 16pt; font-weight: bold;',\n      paste0(\"Growth Adjusted Housing Supply In \", latest_year)\n    )\n  )\n)\n\n# build composite table top 10 and bottom 10 by composite score\ncomp_tbl <- pop_housing %>%\n  filter(year == latest_year, is.finite(composite_score)) %>%\n  mutate(\n    `Metro Area` = short_name3(NAME)\n  ) %>%\n  select(\n    `Metro Area`,\n    Population = population,\n    `Annual Permits` = permits,\n    `Permits per 10k` = permits_per_10k,\n    `Intensity Index` = intensity_index,\n    `Growth Index` = growth_index,\n    `Composite Score` = composite_score\n  )\n\ncomp_high <- comp_tbl %>%\n  arrange(desc(`Composite Score`)) %>%\n  slice_head(n = 10) %>%\n  mutate(Category = \"HIGHEST COMPOSITE\")\n\ncomp_low <- comp_tbl %>%\n  arrange(`Composite Score`) %>%\n  slice_head(n = 10) %>%\n  mutate(Category = \"LOWEST COMPOSITE\")\n\ncomp_final <- bind_rows(comp_high, comp_low) %>%\n  relocate(Category, .before = 1)\n\ndatatable(\n  comp_final %>%\n    mutate(\n      Population = comma(Population),\n      `Annual Permits` = comma(`Annual Permits`),\n      `Permits per 10k` = round(`Permits per 10k`, 2),\n      `Intensity Index` = round(`Intensity Index`, 1),\n      `Growth Index` = round(`Growth Index`, 1),\n      `Composite Score` = round(`Composite Score`, 1)\n    ),\n  rownames = FALSE,\n  options = list(\n    dom = 't',\n    pageLength = 20,\n    autoWidth = TRUE\n  ),\n  caption = htmltools::tags$caption(\n    style = 'caption-side: top; text-align: left; margin-bottom: 10px;',\n    htmltools::tags$div(\n      style = 'font-size: 16pt; font-weight: bold;',\n      paste0(\"Composite Housing Growth Score In \", latest_year)\n    )\n  )\n)\n\n```\n\n## Visualizations For Identifying YIMBY Cities\n\n```{r}\n# Task 6: Visualizations\n# We relate rent burden change, population growth, and housing growth\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(tidyr)\n\n# Compute rent burden change\nrent_change <- rent_burden %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, year, rent_burden_index) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = rent_burden_index,\n    names_prefix = \"rb_\"\n  ) %>%\n  mutate(rent_change = rb_2023 - rb_2009)\n\n# Compute population change 2009–2023\npop_change <- POPULATION %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, population, year) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = population,\n    names_prefix = \"pop_\"\n  ) %>%\n  mutate(pop_change = pop_2023 - pop_2009)\n\n# Build task 6 dataset\ntask6 <- pop_housing %>%\n  filter(year == 2023) %>%\n  select(GEOID, permits_per_10k, intensity_index, pop_growth_5yr, growth_index) %>%\n  left_join(POPULATION %>% select(GEOID, NAME), by = \"GEOID\") %>%\n  left_join(rent_change, by = \"GEOID\") %>%\n  left_join(pop_change, by = \"GEOID\") %>%\n  mutate(\n    yimby_flag = if_else(\n      rb_2009 > median(rb_2009, na.rm = TRUE) &\n      rent_change < 0 &\n      pop_change > 0 &\n      intensity_index > median(intensity_index, na.rm = TRUE) &\n      growth_index > median(growth_index, na.rm = TRUE),\n      \"YIMBY Candidate\", \"Other\"\n    )\n  )\n\n# Color palette\ncbsa_palette <- c(\n  \"YIMBY Candidate\" = \"#1b9e77\",\n  \"Other\" = \"#7570b3\"\n)\n\n```\n\n\nThe following plot examines how changes in rent burden from 2009 to 2023 relate to per-capita housing production in 2023, measured as permits per 10,000 residents. We created this plot to see which metros, if any, build more housing on a per-resident basis and experience smaller increases in rent burden over time.\n\nThe “YIMBY Candidate” metros are those that experienced above-median housing production (as measured by the intensity index) and also saw rent-burden improvement. \n\n```{r}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(tidyr)\n\n# Compute rent burden change 2009 → 2023 \nrent_change <- rent_burden %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, year, rent_burden_index) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = rent_burden_index,\n    names_prefix = \"rb_\"\n  ) %>%\n  mutate(rent_change = rb_2023 - rb_2009)\n\n# compute population change 2009 → 2023 \npop_change <- POPULATION %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, population, year) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = population,\n    names_prefix = \"pop_\"\n  ) %>%\n  mutate(pop_change = pop_2023 - pop_2009)\n\n# data\ntask6 <- pop_housing %>%\n  filter(year == 2023) %>%\n  select(GEOID, permits_per_10k, intensity_index, pop_growth_5yr, growth_index) %>%\n  left_join(POPULATION %>% select(GEOID, NAME), by = \"GEOID\") %>%\n  left_join(rent_change, by = \"GEOID\") %>%\n  left_join(pop_change, by = \"GEOID\") %>%\n  mutate(\n    yimby_flag = if_else(\n      rb_2009 > median(rb_2009, na.rm = TRUE) &\n      rent_change < 0 &\n      pop_change > 0 &\n      intensity_index > median(intensity_index, na.rm = TRUE) &\n      growth_index > median(growth_index, na.rm = TRUE),\n      \"YIMBY Candidate\",\n      \"Other\"\n    )\n  )\n\n# Remove rows with missing values for the plotted vars \nplot_data <- task6 %>%\n  filter(\n    is.finite(rent_change),\n    is.finite(permits_per_10k)\n  )\n\n# plot\nggplot(plot_data, aes(x = rent_change, y = permits_per_10k, color = yimby_flag)) +\n  geom_point(size = 3, alpha = 0.85) +\n  scale_color_manual(values = c(\"YIMBY Candidate\" = \"#1b9e77\", \"Other\" = \"#7570b3\")) +\n  labs(\n    title = \"Rent Burden  vs  Housing Production\",\n    x = \"Change in Rent Burden (Index Points)\",\n    y = \"Permits per 10,000 Residents\",\n    color = \"\"\n  ) +\ntheme_minimal(base_size = 15) +\ntheme(\n    legend.position = \"bottom\",\n    plot.title = element_text(size = 20, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 14, hjust = 0.5)\n)\n\n```\nThe following  two small-multiple plots take a closer look at the six metros that emerged as the strongest YIMBY candidates: Rocky Mount NC, Harrisonburg VA, Yuma AZ, Winchester VA WV, Gulfport Biloxi MS, and Laredo TX. In the first plot, we can see that all six metros experienced a decline in rent burden over time, which is exactly what we would hope to see in places that are building enough housing to keep pressure off prices. \n\nThe second plot shows how much these areas have been building relative to their size, and for most of them the story is consistent. Rocky Mount, Harrisonburg, Yuma, Winchester, and Laredo all exhibit strong per-capita housing production, reinforcing why they score highly as YIMBY metros. \n\nGulfport Biloxi is the one partial outlier: it did reduce rent burden, but its permitting activity does not increase nearly as much as the others. This could mean its affordability gains are driven more by slower demand or population changes than by sustained housing growth.\n\n```{r}\n#Plot 2a\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\n\n# Ensure one row per CBSA\ntask6_unique <- task6 %>% distinct(GEOID, .keep_all = TRUE)\n\n# 2. Filter metros meeting BOTH criteria\n# - rent burden decreased more than typical\n# - housing production per capita higher than typical\n\nyimby_filtered <- task6_unique %>%\n  filter(\n    is.finite(rent_change),\n    is.finite(permits_per_10k)\n  ) %>%\n  filter(\n    rent_change < median(rent_change, na.rm = TRUE),\n    permits_per_10k > median(permits_per_10k, na.rm = TRUE)\n  )\n\n# 3. Pick the TOP 6 best performers:\n#    - most rent burden decrease (more negative is better)\n#    - more permits per 10k secondarily\n\ntop6 <- yimby_filtered %>%\n  arrange(rent_change, desc(permits_per_10k)) %>%\n  slice_head(n = 6) %>%\n  pull(NAME)\n\n# 4. Prepare rent burden time series for these 6 metros\n\nshort_name <- function(x) {\n  sapply(strsplit(x, \" \"), function(y) paste(head(y, 2), collapse = \" \"))\n}\n\nyimby_rent_trends <- rent_burden %>%\n  filter(NAME %in% top6) %>%\n  mutate(short = short_name(NAME))\n\n# 5. Plot 2A — Rent Burden Trends\n\nggplot(yimby_rent_trends, aes(x = year, y = rent_burden_index)) +\n  geom_line(color = \"#1b9e77\", linewidth = 1) +\n  geom_point(color = \"#1b9e77\", size = 2) +\n  facet_wrap(~ short, ncol = 3, scales = \"free_y\") +\n  scale_y_continuous(labels = label_comma()) +\n  labs(\n    title = \"Rent Burden Trends for Top 6 YIMBY Metros\",\n    subtitle = \"Metros that both reduced rent burden and built more housing per capita\",\n    x = \"Year\",\n    y = \"Rent Burden Index (2009 = 100)\"\n  ) +\n  theme_minimal(base_size = 16) +\n  theme(\n    strip.text = element_text(size = 9, face = \"bold\"),\n    plot.title = element_text(face = \"bold\", size = 20, hjust = 0.5),\n    plot.subtitle = element_text(size = 14, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    axis.text.y = element_text(size = 10),\n    panel.spacing = unit(1.2, \"lines\")\n  )\n\n#2b plot\nlibrary(stringr)\n\n# (Optional: If you prefer YOUR manually chosen 6)\n# top6 <- c(\n#   \"Rocky Mount, NC Metro Area\",\n#   \"Harrisonburg, VA Metro Area\",\n#   \"Yuma, AZ Metro Area\",\n#   \"Winchester, VA-WV Metro Area\",\n#   \"Gulfport-Biloxi, MS Metro Area\",\n#   \"Laredo, TX Metro Area\"\n# )\n\nyimby_housing_trends <- pop_housing %>%\n  filter(NAME %in% top6) %>%\n  mutate(short = short_name(NAME))\n\nggplot(yimby_housing_trends, aes(x = year, y = permits_per_10k)) +\n  geom_line(color = \"#1b9e77\", linewidth = 1) +\n  geom_point(color = \"#1b9e77\", size = 2) +\n  facet_wrap(~ short, ncol = 3, scales = \"free_y\") +\n  scale_y_continuous(labels = label_comma()) +\n  labs(\n    title = \"Housing Production Over Time\",\n    subtitle = \"Top 6 YIMBY Candidate Metros Identified in Scatterplot\",\n    x = \"Year\",\n    y = \"Permits per 10,000 Residents\"\n  ) +\n  theme_minimal(base_size = 16) +\n  theme(\n    strip.text = element_text(size = 9, face = \"bold\"),\n    plot.title = element_text(face = \"bold\", size = 20, hjust = 0.5),\n    plot.subtitle = element_text(size = 14, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    panel.spacing = unit(1.2, \"lines\")\n  )\n```\n```{r}\n#data for Policy breif\n# Find start and end values for Rocky Mount\nrb_rm <- rent_burden %>%\n  filter(NAME == \"Rocky Mount, NC Metro Area\") %>%\n  arrange(year)\n\nrb_rm_start <- rb_rm$rent_burden_index[1]\nrb_rm_end   <- rb_rm$rent_burden_index[nrow(rb_rm)]\n\nrent_burden_pct_change <- (rb_rm_end - rb_rm_start) / rb_rm_start * 100\nrent_burden_pct_change\n\n# Compute Rocky Mount housing production % change using permits_per_10k\n\nhg_rm <- pop_housing %>%\n  filter(NAME == \"Rocky Mount, NC Metro Area\") %>%\n  arrange(year)\n\nhg_rm_start <- hg_rm$permits_per_10k[1]\nhg_rm_end   <- hg_rm$permits_per_10k[nrow(hg_rm)]\n\nhousing_growth_pct_change <- (hg_rm_end - hg_rm_start) / hg_rm_start * 100\nhousing_growth_pct_change\n\n```\n\n# Policy Brief\n\n## Backyards For All Bill: Why All Americans Deserve Affordable Housing\n\n\nAmerica’s housing shortage continues to push rents upward in many major metropolitan cities, New York being one of the most dire examples, with only around 1% of housing units are vacant. As a result, many working class people are either getting pushed out of their cities, or suffering a loss in standard of living year over year. With general inflation running rampant in recent years, it is imperative that a change be made to bring releif to everyday Americans. \n\nThis proposal establishes a competitive federal program that rewards cities for modernizing zoning, approving homes more efficiently, and reducing rent burdens. The goal is simple: accelerate homebuilding in the places where Americans already live, work, and want to stay.\n\n\n**Primary sponsor**: \n\nA congressional representative from Rocky Mount, NC Metro Area — one of the clearest YIMBY successes in our analysis. Rocky Mount permitted housing at strong per-capita levels and saw a meaningful decline in rent burden over time. Rocky Mount is an ideal sponsor becasue they were able to implement a 28% increase in housing growth which led to a 20% decrease in rent burden for their population.\n\n**Co-sponsor**: \n\nA congressional representative from New York City, NY Metro Area — a high-rent, slower-to-build region where the affordability crisis is sharpest and federal incentives would have the biggest impact. \n\n**Support groups:** \n\nMobilize Nurses and other healthcare workers (SEIU, National Nurses United).\n\nBoth Rocky Mount and NYC have substantial healthcare workforces. In cities that permit more housing, rent burdens fall, leaving nurses with more disposable income and reducing turnover for hospitals and clinics. This stabilizes nurse staffing, which is a top concern for these unions.\n\nTeachers and school staff (AFT, NEA).\nEducators make up a large, locally rooted voting bloc in both metros. Lower rent burden helps teachers stay in their districts instead of commuting long distances or leaving the profession. Currently, 33% of teachers in NYC live outside of the city due to high rent prices (Independent Budget Office 2019). \n\n**What the program funds:**\n\n- Performance-based grants for cities that legalize more homes near jobs and transit, digitize their permitting processes, and demonstrate progress in lowering rent burden.\n\n- Technical assistance including model zoning codes and pre-approved residential plans.\n\n**How we measure success:**\n\n- Rent-burden index: We compare typical rent to typical household income and scale everything so 2009 = 100. When a city’s index falls below 100 over time, residents are spending a smaller share of their income on rent, this is a clear sign of improved affordability.\n\n- Housing-growth metrics: Permits per 10,000 residents: A per-capita measure of how much a city is building today, allowing for fair comparison across metros.\n\n- Growth-adjusted index: Permits relative to each city’s five-year population growth, answering whether a city is building enough to keep up with demand.\n\n**Why NewYorkers Will all Benefit:**\n\nNew York is known as \"the city that never sleeps\" however, anyone who lives there will tell you that this saying hardly hold true today. Most shops, restaurants and cafes are closed by 9 or 10pm even on weekends. What caused this? For most of its history, New York was an industrial city. Factory workers kept long, irregular hours and the businesses around them stayed open late to match their schedules. After that era ended, the city became a hub for artists, who also tended to live and work on nontraditional hours, keeping New York’s late night culture alive.\n\nToday, Manhattan has undergone a wave of corporate consolidation. Large companies have bought up much of the real estate, and as prices rose, artists and other creative workers were pushed to the outer boroughs while corporate employees with more conventional schedules replaced them. Neighborhoods in Brooklyn and Queens still hold onto pieces of the old nightlife energy, but in Manhattan it has mostly faded.\n  \nMaking housing more affordable in Manhattan by building more homes would help reverse this shift. If younger people and artists could actually afford to live there again, the city could begin to regain some of the vibrancy that once defined it. This would not only improve the quality of life for Gen Z and Millennials, but it would also boost the broader city economy. The nightlife sector alone contributes about 35 billion dollars to New York City’s economy, and restoring that culture would help strengthen the city as a whole (Mayor’s Office of Media and Entertainment, 2019). \n\n\nTogether, these measures reward cities that both build more housing and reduce rent pressure. \n\n**Citations**\n\nMayor’s Office of Media and Entertainment. (2019). NYC Nightlife Economic Impact Report. Retrieved from https://www.nyc.gov/assets/mome/pdf/NYC_Nightlife_Economic_Impact_Report_2019_digital.pdf\n\nNew York City Independent Budget Office. (2019). Where Do NYC’s Teachers and Principals Live Compared With Where They Work? Retrieved from https://www.ibo.nyc.ny.us/iboreports/printnycbtn19.pdf","srcMarkdownNoYaml":"\n## Introduction\n\nHousing affordability has become a huge challenge facing cities across the country, the supply of housing just cannot keep up with the demand. A lot of the debate comes down to two clashing philosophies: YIMBY (“Yes In My Backyard”), which argues that cities should make it easier to build housing, and NIMBY (“Not In My Backyard”), which pushes back against new development out of fear that it will change neighborhood character, lead to gentrification, or hurt property values. It’s a controversial topic because both sides claim to be protecting their communities. \n\nIn this project, we will dig into Census, ACS and BLS data to see which metro areas are  embracing the YIMBY approach and which ones are effectively blocking growth. We will build rent burden and housing growth metrics, track trends across hundreds of CBSAs, and identify a handful of metros that stand out as YIMBY success stories. \n\n\n```{r, results='hide', message=FALSE, warning=FALSE}\ntidycensus::census_api_key(\"aa14982ecd4bb502eb657c121f3d02e9b1c45cee\", install = FALSE)\n\ngetwd()\nlist.files(\"data\", recursive = TRUE)\n\n\nif(!dir.exists(file.path(\"data\", \"mp02\"))){\n    dir.create(file.path(\"data\", \"mp02\"), showWarnings=FALSE, recursive=TRUE)\n}\n\nlibrary <- function(pkg){\n    ## Mask base::library() to automatically install packages if needed\n    ## Masking is important here so downlit picks up packages and links\n    ## to documentation\n    pkg <- as.character(substitute(pkg))\n    options(repos = c(CRAN = \"https://cloud.r-project.org\"))\n    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)\n    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))\n}\n\nlibrary(tidyverse)\nlibrary(glue)\nlibrary(readxl)\nlibrary(tidycensus)\n\nget_acs_all_years <- function(variable, geography=\"cbsa\",\n                              start_year=2009, end_year=2023){\n    fname <- glue(\"{variable}_{geography}_{start_year}_{end_year}.csv\")\n    fname <- file.path(\"data\", \"mp02\", fname)\n    \nif(!file.exists(fname)){\n        YEARS <- seq(start_year, end_year)\n        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)\n        \n        ALL_DATA <- map(YEARS, function(yy){\n            tidycensus::get_acs(geography, variable, year=yy, survey=\"acs1\") |>\n                mutate(year=yy) |>\n                select(-moe, -variable) |>\n                rename(!!variable := estimate)\n        }) |> bind_rows()\n        \n        write_csv(ALL_DATA, fname)\n    }\n    \n    read_csv(fname, show_col_types=FALSE)\n}\n\n# Household income (12 month)\nINCOME <- get_acs_all_years(\"B19013_001\") |>\n    rename(household_income = B19013_001)\n\n# Monthly rent\nRENT <- get_acs_all_years(\"B25064_001\") |>\n    rename(monthly_rent = B25064_001)\n\n# Total population\nPOPULATION <- get_acs_all_years(\"B01003_001\") |>\n    rename(population = B01003_001)\n\n# Total number of households\nHOUSEHOLDS <- get_acs_all_years(\"B11001_001\") |>\n    rename(households = B11001_001)\nget_building_permits <- function(start_year = 2009, end_year = 2023){\n    fname <- glue(\"housing_units_{start_year}_{end_year}.csv\")\n    fname <- file.path(\"data\", \"mp02\", fname)\n    \n    if(!file.exists(fname)){\n        HISTORICAL_YEARS <- seq(start_year, 2018)\n        \n        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){\n            historical_url <- glue(\"https://www.census.gov/construction/bps/txt/tb3u{yy}.txt\")\n                \n            LINES <- readLines(historical_url)[-c(1:11)]\n\n            CBSA_LINES <- str_detect(LINES, \"^[[:digit:]]\")\n            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))\n\n            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), \"[[:digit:]]\")\n            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))\n            \n            data_frame(CBSA = CBSA,\n                       new_housing_units_permitted = PERMITS, \n                       year = yy)\n        }) |> bind_rows()\n        \n        CURRENT_YEARS <- seq(2019, end_year)\n        \n        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){\n            current_url <- glue(\"https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls\")\n            \n            temp <- tempfile()\n            \n            download.file(current_url, destfile = temp, mode=\"wb\")\n            \n            fallback <- function(.f1, .f2){\n                function(...){\n                    tryCatch(.f1(...), \n                             error=function(e) .f2(...))\n                }\n            }\n            \n            reader <- fallback(read_xlsx, read_xls)\n            \n            reader(temp, skip=5) |>\n                na.omit() |>\n                select(CBSA, Total) |>\n                mutate(year = yy) |>\n                rename(new_housing_units_permitted = Total)\n        }) |> bind_rows()\n        \n        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)\n        \n        write_csv(ALL_DATA, fname)\n        \n    }\n    \n    read_csv(fname, show_col_types=FALSE)\n}\n\nPERMITS <- get_building_permits()\n\nlibrary(httr2)\nlibrary(rvest)\nget_bls_industry_codes <- function(){\n    fname <- file.path(\"data\", \"mp02\", \"bls_industry_codes.csv\")\n    library(dplyr)\n    library(tidyr)\n    library(readr)\n    \n    if(!file.exists(fname)){\n        \n        resp <- request(\"https://www.bls.gov\") |> \n            req_url_path(\"cew\", \"classifications\", \"industry\", \"industry-titles.htm\") |>\n            req_headers(`User-Agent` = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0\") |> \n            req_error(is_error = \\(resp) FALSE) |>\n            req_perform()\n        \n        resp_check_status(resp)\n        \n        naics_table <- resp_body_html(resp) |>\n            html_element(\"#naics_titles\") |> \n            html_table() |>\n            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), \"NAICS\"))) |>\n            select(-`Industry Title`) |>\n            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>\n            filter(!is.na(depth))\n        \n        # These were looked up manually on bls.gov after finding \n        # they were presented as ranges. Since there are only three\n        # it was easier to manually handle than to special-case everything else\n        naics_missing <- tibble::tribble(\n            ~Code, ~title, ~depth, \n            \"31\", \"Manufacturing\", 1,\n            \"32\", \"Manufacturing\", 1,\n            \"33\", \"Manufacturing\", 1,\n            \"44\", \"Retail\", 1, \n            \"45\", \"Retail\", 1,\n            \"48\", \"Transportation and Warehousing\", 1, \n            \"49\", \"Transportation and Warehousing\", 1\n        )\n        \n        naics_table <- bind_rows(naics_table, naics_missing)\n        \n        naics_table <- naics_table |> \n            filter(depth == 4) |> \n            rename(level4_title=title) |> \n            mutate(level1_code = str_sub(Code, end=2), \n                   level2_code = str_sub(Code, end=3), \n                   level3_code = str_sub(Code, end=4)) |>\n            left_join(naics_table, join_by(level1_code == Code)) |>\n            rename(level1_title=title) |>\n            left_join(naics_table, join_by(level2_code == Code)) |>\n            rename(level2_title=title) |>\n            left_join(naics_table, join_by(level3_code == Code)) |>\n            rename(level3_title=title) |>\n            select(-starts_with(\"depth\")) |>\n            rename(level4_code = Code) |>\n            select(level1_title, level2_title, level3_title, level4_title, \n                   level1_code,  level2_code,  level3_code,  level4_code) |>\n            drop_na() |>\n            mutate(across(contains(\"code\"), as.integer))\n        \n        write_csv(naics_table, fname)\n    }\n    \n    read_csv(fname, show_col_types=FALSE)\n}\n\nINDUSTRY_CODES <- get_bls_industry_codes()\nlibrary(httr2)\nlibrary(rvest)\nget_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){\n    fname <- glue(\"bls_qcew_{start_year}_{end_year}.csv.gz\")\n    fname <- file.path(\"data\", \"mp02\", fname)\n    \n    YEARS <- seq(start_year, end_year)\n    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS\n    \n    if(!file.exists(fname)){\n        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){\n            fname_inner <- file.path(\"data\", \"mp02\", glue(\"{yy}_qcew_annual_singlefile.zip\"))\n            \n            if(!file.exists(fname_inner)){\n                request(\"https://www.bls.gov\") |> \n                    req_url_path(\"cew\", \"data\", \"files\", yy, \"csv\",\n                                 glue(\"{yy}_annual_singlefile.zip\")) |>\n                    req_headers(`User-Agent` = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0\") |> \n                    req_retry(max_tries=5) |>\n                    req_perform(fname_inner)\n            }\n            \n            if(file.info(fname_inner)$size < 755e5){\n                warning(sQuote(fname_inner), \"appears corrupted. Please delete and retry this step.\")\n            }\n            \n            read_csv(fname_inner, \n                     show_col_types=FALSE) |> \n                mutate(YEAR = yy) |>\n                select(area_fips, \n                       industry_code, \n                       annual_avg_emplvl, \n                       total_annual_wages, \n                       YEAR) |>\n                filter(nchar(industry_code) <= 5, \n                       str_starts(area_fips, \"C\")) |>\n                filter(str_detect(industry_code, \"-\", negate=TRUE)) |>\n                mutate(FIPS = area_fips, \n                       INDUSTRY = as.integer(industry_code), \n                       EMPLOYMENT = as.integer(annual_avg_emplvl), \n                       TOTAL_WAGES = total_annual_wages) |>\n                select(-area_fips, \n                       -industry_code, \n                       -annual_avg_emplvl, \n                       -total_annual_wages) |>\n                # 10 is a special value: \"all industries\" , so omit\n                filter(INDUSTRY != 10) |> \n                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)\n        })) |> bind_rows()\n        \n        write_csv(ALL_DATA, fname)\n    }\n    \n    ALL_DATA <- read_csv(fname, show_col_types=FALSE)\n    \n    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)\n    \n    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)\n    \n    if(length(YEARS_DIFF) > 0){\n        stop(\"Download failed for the following years: \", YEARS_DIFF, \n             \". Please delete intermediate files and try again.\")\n    }\n    \n    ALL_DATA\n}\n\nWAGES <- get_bls_qcew_annual_averages()\n```\n## Initial Data Exploration\n\n1. Which CBSA (by name) permitted the largest number of new housing units in the decade from 2010 to 2019 (inclusive)?\n\nThe **Houston-Sugarland-Baytown** area in Texas has permitted the largest number of housing units from 2010 to 2019 during which they allowed 482,075 units to be built.\n\n```{r, results='hide', message=FALSE, warning=FALSE}\nlibrary(tidyverse)\n\n# Load the housing data\nhousing <- read_csv(\"data/mp02/housing_units_2009_2023.csv\")\n\n# Check the first few rows and structure\nglimpse(housing)\n\n#| include: false\n# Filter housing data for 2010-2019\nhousing_2010_2019 <- housing |>\n  filter(year >= 2010 & year <= 2019)\n\n# Quick check\nglimpse(housing_2010_2019)\n\n#| include: false\n# Sum new housing units per CBSA for the decade\nhousing_summed <- housing_2010_2019 |>\n  group_by(CBSA) |>\n  summarise(total_units = sum(new_housing_units_permitted, na.rm = TRUE)) |>\n  arrange(desc(total_units))\n\n# Look at top CBSA totals\nhead(housing_summed, 10)\n\n#| echo: true\n# Sum new housing units per CBSA for the decade\nhousing_summed <- housing_2010_2019 |>\n  group_by(CBSA) |>\n  summarise(total_units = sum(new_housing_units_permitted, na.rm = TRUE)) |>\n  arrange(desc(total_units))\n\n# Load CBSA metadata\ncbsa_meta <- read_csv(\"data/mp02/B01003_001_cbsa_2009_2023.csv\")\n\n# Join summed housing with CBSA names using GEOID\nhousing_named <- housing_summed |>\n  left_join(cbsa_meta, by = c(\"CBSA\" = \"GEOID\"))\n\n# Show the CBSA with the largest total units\nhousing_named |> slice(1)\n\n#| echo: true\nlibrary(DT)\n\n# Get the CBSA with the largest total units\ntop_cbsa <- housing_named |>\nrename(Population = B01003_001) |>\nselect(CBSA, NAME, total_units, Population, year) |>\nslice(1)\n```\n```{r}\n# Display as clean data table\ndatatable(\ntop_cbsa,\ncolnames = c(\"CBSA\", \"Name\", \"Total Units\", \"Population\", \"Year\"),\noptions = list(dom = 't', autoWidth = TRUE),\nrownames = FALSE\n) |>\nformatCurrency(columns = c(\"total_units\", \"Population\"), currency = \"\", digits = 0) #commas in numbers \n \n\n\n \n\n# \n```  \n\n\n2. In what year did Albuquerque, NM (CBSA Number 10740) permit the most new housing units?\n\nHint: There is a Covid-19 data artifact here that may trip you up if you do not look at your answer closely.\n\nAlbuquerque permitted the most new housing in 2021. However, this year was an anomaly likely due to COVID-19 related slowdowns in the year prior. Other than 2021, the highest number of permits were issued in **2022** when **2,852** new housing units were permitted to be built. \n\n```{r}\n# Make sure PERMITS exists\n\npermits <- get_building_permits()\nlibrary(tidyverse)\nlibrary(DT)\n\n# Filter for Albuquerque, NM (CBSA 10740) and show top 10 years\n\nalbuquerque_top10 <- permits |>\nfilter(CBSA == 10740) |>\narrange(desc(new_housing_units_permitted)) |>\nslice_head(n = 10)\n\n# Display as a clean interactive table\n\ndatatable(\nalbuquerque_top10,\ncolnames = c(\"CBSA\", \"New Units Permitted\", \"Year\"),\noptions = list(dom = 't', autoWidth = TRUE),\nrownames = FALSE\n) |>\nformatCurrency(columns = \"new_housing_units_permitted\", currency = \"\", digits = 0)\n\n#\n```\n\n3. Which state (not CBSA) had the highest average individual income in 2015? To answer this question, you will need to first compute the total income per CBSA by multiplying the average household income by the number of households, and then sum total income and total population across all CBSAs in a state. With these numbers, you can answer this question.\n\nThough not technically a state, **Washington D.C**. had the highest average individual income. \n\n\n```{r}\nlibrary(dplyr)\nlibrary(stringr)\n\n# 1. Merge the 2015 data sets\nacs_2015 <- INCOME |> \n  filter(year == 2015) |>\n  left_join(HOUSEHOLDS |> filter(year == 2015), by = c(\"GEOID\", \"NAME\", \"year\")) |>\n  left_join(POPULATION |> filter(year == 2015),  by = c(\"GEOID\", \"NAME\", \"year\"))\n\n# 2. Compute total income per CBSA\nacs_2015 <- acs_2015 |>\n  mutate(total_income = household_income * households)\n\n# 3. Extract the principal state abbreviation from the CBSA name\nacs_2015 <- acs_2015 |>\n  mutate(state = str_extract(NAME, \", (.{2})\", group = 1))\n\n# 4. Aggregate to the state level\nstate_summary <- acs_2015 |>\n  group_by(state) |>\n  summarise(\n    total_income = sum(total_income, na.rm = TRUE),\n    total_population = sum(population, na.rm = TRUE)\n  ) |>\n  mutate(avg_individual_income = total_income / total_population)\n\n# 5. Add full state names\nstate_df <- data.frame(\n  abb  = c(state.abb, \"DC\", \"PR\"),\n  name = c(state.name, \"District of Columbia\", \"Puerto Rico\")\n)\n\nstate_summary <- state_summary |>\n  left_join(state_df, by = c(\"state\" = \"abb\")) |>\n  arrange(desc(avg_individual_income))\n\n\n```\n```{r}\n#Display data table\n\ndatatable(\n  state_summary |> \n    arrange(desc(avg_individual_income)) |> \n    rename(\n      State = state,\n      `Total Income` = total_income,\n      Population = total_population,\n      `Avg. Individual Income` = avg_individual_income\n    ),\n  options = list(\n    pageLength = 10,    # show 10 rows per page\n    autoWidth = TRUE\n  ),\n  rownames = FALSE\n) |>\n  formatCurrency(\n    columns = c(\"Total Income\", \"Population\", \"Avg. Individual Income\"),\n    currency = \"\", \n    digits = 0\n  )\n\n\n#\n```\n\n\n4. Data scientists and business analysts are recorded under NAICS code 5182. What is the last year in which the NYC CBSA had the most data scientists in the country? In recent, the San Francisco CBSA has had the most data scientists.\n\n **2015** was the last time that New York had the most data scientists in the country; that year they employed **18,922** data scientists. \n\n\n```{r, results='hide', message=FALSE, warning=FALSE}\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(DT)\n\n# Create a new CBSA join key in WAGES\nWAGES <- WAGES |>\n  mutate(\n    CBSA_join = as.double(paste0(str_remove(FIPS, \"C\"), \"0\"))\n  )\n\n# Filter for data scientists (NAICS 5182)\ndata_sci <- WAGES |>\n  filter(INDUSTRY == 5182) |>\n  select(CBSA_join, EMPLOYMENT, YEAR)\n\n# Join to get CBSA names\ndata_sci_named <- data_sci |>\n  inner_join(cbsa_meta |> select(GEOID, NAME), by = c(\"CBSA_join\" = \"GEOID\"))\n\n# Find which CBSA had the most per year\ntop_data_sci_each_year <- data_sci_named |>\n  group_by(YEAR) |>\n  slice_max(order_by = EMPLOYMENT, n = 1, with_ties = FALSE) |>\n  arrange(YEAR)\n```\n```{r}\n# Display as a nice interactive table\ndatatable(\n  top_data_sci_each_year |>\n    rename(\n      Year = YEAR,\n      CBSA = NAME,\n      Employment = EMPLOYMENT\n    ),\n  options = list(pageLength = 10, autoWidth = TRUE),\n  rownames = FALSE\n) |>\n  formatCurrency(columns = \"Employment\", currency = \"\", digits = 0)\n\n#\n```\n\n5. What fraction of total wages in the NYC CBSA was earned by people employed in the finance and insurance industries (NAICS code 52)? In what year did this fraction peak?\n\nIn **2021** the fraction of total wages earned by people in the finance industry peaked at **15.87%**\n\n```{r, results='hide', message=FALSE, warning=FALSE}\n### Q5. What fraction of total wages in the NYC CBSA \n### was earned by people employed in the Finance & Insurance industries (NAICS 52)?\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(scales)\n\n# 1. Compute total wages for all industries in NYC CBSA (C3562)\ntotal_nyc_wages <- WAGES |>\n  filter(FIPS == \"C3562\") |>\n  group_by(YEAR) |>\n  summarise(total_wages = sum(TOTAL_WAGES, na.rm = TRUE))\n\n# 2. Compute total wages for Finance & Insurance (NAICS 52xx)\nfinance_insurance_nyc <- WAGES |>\n  filter(FIPS == \"C3562\", str_starts(as.character(INDUSTRY), \"52\")) |>\n  group_by(YEAR) |>\n  summarise(finance_insurance_wages = sum(TOTAL_WAGES, na.rm = TRUE))\n\n# 3. Combine and compute percent of total\nfinance_insurance_percent <- finance_insurance_nyc |>\n  inner_join(total_nyc_wages, by = \"YEAR\") |>\n  mutate(\n    percent_of_total = (finance_insurance_wages / total_wages) * 100\n  ) |>\n  arrange(desc(percent_of_total)) |>\n  select(YEAR, total_wages, finance_insurance_wages, percent_of_total)\n\n# 4. Print the full table nicely formatted\nprint(\n  finance_insurance_percent,\n  n = nrow(finance_insurance_percent)\n)\n\n# 5. Identify the peak year and percent\npeak_row <- finance_insurance_percent |> slice(1)\npeak_year <- peak_row$YEAR\npeak_share <- percent(peak_row$percent_of_total / 100, accuracy = 0.01)\n```\n```{r}\n# 6. Display concise summary\ncat(\"\\n\")\ncat(\"Peak Year:\", peak_year, \"\\n\")\ncat(\"Finance & Insurance Share of Total Wages:\", peak_share, \"\\n\")\n\n\n```\n\n## Data Visualization\n```{r}\n#relationship between Monthly Rent and Average Household Income per CBSA in 2009\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(scales)\n\n# 1. Filter and join data for 2009\nrent_income_2009 <- RENT |>\n  filter(year == 2009) |>\n  inner_join(\n    INCOME |>\n      filter(year == 2009),\n    by = \"GEOID\"\n  ) |>\n  rename(\n    monthly_rent = monthly_rent,\n    household_income = household_income\n  ) |>\n  left_join(cbsa_meta |> select(GEOID, NAME), by = \"GEOID\")\n\n# 2. Fit linear model to get R²\nmodel <- lm(monthly_rent ~ household_income, data = rent_income_2009)\nr2_value <- summary(model)$r.squared\n\n# 3. Create scatter plot with R² annotation\nggplot(rent_income_2009, aes(x = household_income, y = monthly_rent)) +\n  geom_point(alpha = 0.6, color = \"steelblue\") +\n  geom_smooth(method = \"lm\", se = FALSE, color = \"darkred\", linetype = \"dashed\") +\n  scale_x_continuous(labels = label_comma()) +\n  scale_y_continuous(labels = label_comma()) +\n  annotate(\n    \"text\",\n    x = Inf, y = -Inf,\n    label = paste0(\"R² = \", round(r2_value, 3)),\n    hjust = 1.1, vjust = -1.1,\n    size = 5,\n    color = \"black\"\n  ) +\n  labs(\n    title = \"Monthly Rent vs. Average Household Income per CBSA (2009)\",\n    subtitle = \"Each point represents one CBSA\",\n    x = \"Average Household Income ($)\",\n    y = \"Average Monthly Rent ($)\",\n    caption = \"Source: ACS 1-Year Estimates (2009)\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5)\n  )\n\n```\nThere is a correlation between rent and household income in 2009. The R-squared value is nearly 0.6, indicating a fairly strong positive correlation between the two. That being said, there is a fair amount deviation from the linear model. \n\n```{r}\n# Health Care & Social Assistance vs. Total Employment (NAICS 62) small multiples plot\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(broom)\n\n# 1) Total employment per CBSA per year\ntotal_emp <- WAGES |>\n  filter(YEAR >= 2013, YEAR <= 2023, YEAR != 2020) |>\n  group_by(FIPS, YEAR) |>\n  summarise(total_employment = sum(as.numeric(EMPLOYMENT), na.rm = TRUE), .groups = \"drop\")\n\n# 2) Health care employment (NAICS 62xx)\nhealth_emp <- WAGES |>\n  filter(YEAR >= 2013, YEAR <= 2023, YEAR != 2020,\n         str_starts(as.character(INDUSTRY), \"62\")) |>\n  group_by(FIPS, YEAR) |>\n  summarise(health_employment = sum(as.numeric(EMPLOYMENT), na.rm = TRUE), .groups = \"drop\")\n\n# 3) Join and compute R² for each year\nemp_combined <- total_emp |>\n  inner_join(health_emp, by = c(\"FIPS\", \"YEAR\"))\n\nr2_by_year <- emp_combined |>\n  group_by(YEAR) |>\n  summarise(\n    r2 = summary(lm(health_employment ~ total_employment))$r.squared,\n    .groups = \"drop\"\n  )\n\n# 4) Plot — clean, professional look\nggplot(emp_combined, aes(x = total_employment, y = health_employment)) +\n  geom_point(alpha = 0.45, size = 0.8, color = \"seagreen4\") +\n  geom_smooth(method = \"lm\", se = FALSE, linetype = \"dashed\", color = \"firebrick3\") +\n  facet_wrap(~ YEAR, ncol = 5, scales = \"fixed\") +\n  # compact axis labels (e.g., 200K, 1M)\n  scale_x_continuous(labels = label_number(scale_cut = cut_short_scale())) +\n  scale_y_continuous(labels = label_number(scale_cut = cut_short_scale())) +\n  labs(\n    title = \"Health Care Employment vs. Total Employment Across CBSAs\",\n    subtitle = \"Small multiples show evolution by year \",\n    x = \"Total Employment \",\n    y = \"Health Care & Social Assistance Employment \",\n    caption = \"Source: BLS QCEW Annual Averages (excludes 2020)\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5),\n    strip.text = element_text(face = \"bold\"),\n    axis.text.x = element_text(size = 8),\n    panel.grid.minor = element_blank(),\n    panel.grid.major = element_line(color = \"grey90\")\n  ) \n  # Annotate R² per facet\n \n```\n\nThis plot shows the correlation between healthcare employment and total employment and how it has changed over the years. Based on the data, the strong linear correlation has been virtually unchanged; the s-squared fluctuating only about 0.01 over time. \n\n\n```{r}\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(stringr)\n\n# Combine and compute household size\nhousehold_size <- HOUSEHOLDS |>\n  select(GEOID, NAME, households, year) |>\n  left_join(\n    POPULATION |> select(GEOID, population, year),\n    by = c(\"GEOID\", \"year\")\n  ) |>\n  mutate(avg_household_size = population / households)\n\n# Label NYC and LA dynamically (regex-safe)\nhousehold_size <- household_size |>\n  mutate(highlight = case_when(\n    str_detect(NAME, regex(\"New York\", ignore_case = TRUE)) ~ \"New York\",\n    str_detect(NAME, regex(\"Los Angeles\", ignore_case = TRUE)) ~ \"Los Angeles\",\n    TRUE ~ \"Other CBSAs\"\n  ))\n\n# Plot\nggplot(household_size, aes(x = year, y = avg_household_size, group = NAME)) +\n  geom_line(aes(color = highlight), alpha = 0.8, linewidth = 0.6) +\n  scale_color_manual(\n    values = c(\n      \"New York\" = \"steelblue\",\n      \"Los Angeles\" = \"darkorange\",\n      \"Other CBSAs\" = \"grey80\"\n    )\n  ) +\n  labs(\n    title = \"Time vs. Average Household Size\",\n    subtitle = \"New York and Los Angeles highlighted\",\n    x = \"Year\",\n    y = \"Average Household Size\",\n    color = \"CBSA\",\n    caption = \"Source: ACS 1-Year Estimates (excluding 2020)\"\n  ) +\n  theme_minimal(base_size = 13) +\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5)\n  )\n```\n\nThough jumbled, this plot is showing us the average household size and how it has been changing over the years. Each line represents a different CBSA. The blue and orange lines are highlighted to show NYC and LA. The graph is showing a downward trend, particularly in large cities like L.A. and NYC. \n\n\n## Building Indices of Housing Affordability and Housing Stock Growth\n\n### Rent Burden Table \n\n- Rent to income ratio: annual rent/ annual income\n- Rent burden index: we will use the 2009 as the baseline rent to income ratio and calculate the relative rent burden for the subsequent years using this value.\n- 2009 represents 100%, anything above will mean that the rent burden has increased, anything below 100% will mean that the burden has decreased relative to 2009. \n\n\n\n\n\n\n```{r}\n##Task 4\nlibrary(dplyr)\n\n# 1. Merge INCOME and RENT\nrent_burden <- INCOME |>\n  select(GEOID, NAME, year, household_income) |>\n  left_join(\n    RENT |> select(GEOID, year, monthly_rent),\n    by = c(\"GEOID\", \"year\")\n  ) |>\n  mutate(\n    # raw rent burden = annual rent / annual income\n    rent_to_income = (12 * monthly_rent) / household_income\n  ) |>\n  filter(is.finite(rent_to_income))\n\n# 2. Compute the baseline (national average rent burden in 2009)\nbaseline_2009 <- rent_burden |>\n  filter(year == 2009) |>\n  summarise(baseline = mean(rent_to_income, na.rm = TRUE)) |>\n  pull(baseline)\n\n# 3. Create standardized measures\nrent_burden <- rent_burden |>\n  mutate(\n    rent_burden_relative = rent_to_income / baseline_2009,  # multiple of 2009 burden\n    rent_burden_index = rent_burden_relative * 100          # percent of baseline\n  )\n\n\n```\n```{r}\nlibrary(DT)\nlibrary(dplyr)\n\n# NYC table\nnyc_rent_burden <- rent_burden |>\n  filter(NAME == \"New York-Newark-Jersey City, NY-NJ-PA Metro Area\") |>\n  arrange(year) |>\n  select(\n    year,\n    rent_to_income,\n    rent_burden_index\n  )\n\ndatatable(\n  nyc_rent_burden,\n  colnames = c(\"Year\", \"Rent-to-Income (%)\", \"Rent Burden Index (%)\"),\n  caption = htmltools::tags$caption(\n    style = '\n      caption-side: top;\n      text-align: center;\n      font-weight: bold;\n      color: black;\n      font-size: 18px;\n    ',\n    \"New York Metro Area — Rent Burden Over a Ten Year Period\"\n  ),\n  options = list(pageLength = 10, autoWidth = TRUE),\n  rownames = FALSE\n) |>\n\n  formatPercentage(columns = \"rent_to_income\", digits = 1) |>\n    formatRound(columns = \"rent_burden_index\", digits = 1)\n  \n\n\n```\n\n```{r}\n#Scatterplot\nnyc_plot_data <- rent_burden |>\n  filter(NAME == \"New York-Newark-Jersey City, NY-NJ-PA Metro Area\") |>\n  arrange(year)\n\nnyc_plot_data$year <- as.factor(nyc_plot_data$year)\n\nggplot(nyc_plot_data, aes(x = year, y = rent_burden_index, group = 1)) +\n  geom_point(size = 2, color = \"steelblue\") +\n  geom_line(color = \"steelblue\", linewidth = 1) +\n  labs(\n    title = \"NYC Rent Burden Index Over Time\",\n    subtitle = \"Standardized so 100 = national average rent burden in 2009\",\n    x = \"Year\",\n    y = \"Rent Burden Index (2009 = 100)\"\n  ) +\n  theme_minimal(base_size = 14) +\n  theme(\n    plot.title = element_text(face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1)\n  )\n\n```\nThis plot is showing the changes in rent burden in NYC from 2013 to 2023 in reference to 2009. Notice that the rent burden has fluctuated with no real patten over the past decade. \n\n```{r}\n#Comparing metro areas rent burdens\nlibrary(dplyr)\nlibrary(DT)\n\n# Identify latest year\nlatest_year <- max(rent_burden$year)\n\n# Compute rankings\nrent_burden_ranked <- rent_burden |>\n  filter(year == latest_year) |>\n  arrange(desc(rent_burden_index)) |>\n  select(NAME, year, rent_burden_index, rent_to_income)\n\n# Top + bottom 10\nhighest_10 <- rent_burden_ranked |> slice_head(n = 10)\nlowest_10  <- rent_burden_ranked |> slice_tail(n = 10)\n#make highest burden datatable\ndatatable(\n  highest_10,\n  caption = htmltools::tags$caption(\n    style = '\n      caption-side: top;\n      text-align: center;\n      font-weight: 900;\n      color: black;\n      font-size: 20px;\n    ',\n    paste0(\"Top 10 Highest Rent Burden Metros in \", latest_year)\n  ),\n  rownames = FALSE\n) |>\n  formatPercentage(\"rent_to_income\", digits = 1) |>\n  formatRound(\"rent_burden_index\", digits = 1)\n\n#Lowest burden\ndatatable(\n  lowest_10,\n  caption = htmltools::tags$caption(\n    style = '\n      caption-side: top;\n      text-align: center;\n      font-weight: 900;\n      color: black;\n      font-size: 20px;\n    ',\n    paste0(\"Top 10 Lowest Rent Burden Metros in \", latest_year)\n  ),\n  rownames = FALSE\n) |>\n  formatPercentage(\"rent_to_income\", digits = 1) |>\n  formatRound(\"rent_burden_index\", digits = 1)\n\n#scatterplot\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(scales)\n\n# Pick latest available year\nlatest_year <- max(rent_burden$year, na.rm = TRUE)\n\n# Filter for that year\nrb_latest <- rent_burden |>\n  filter(year == latest_year)\n\n# Identify high/low groups\nn_high <- 10\nn_low  <- 10\n\nhigh_ids <- rb_latest |> slice_max(rent_burden_index, n = n_high) |> pull(GEOID)\nlow_ids  <- rb_latest |> slice_min(rent_burden_index, n = n_low) |> pull(GEOID)\n\n# Classification\nrb_latest <- rb_latest |>\n  mutate(\n    group = case_when(\n      GEOID %in% high_ids ~ \"10 Most Rent Burdened\",\n      GEOID %in% low_ids  ~ \"10 Least Rent Burdened\",\n      TRUE ~ \"Other\"\n    )\n  )\n\n# Scatter plot\nggplot(rb_latest, aes(x = household_income, y = rent_burden_index)) +\n  geom_point(aes(color = group), size = 3, alpha = 0.8) +\n  \n\n  scale_x_continuous(labels = label_comma()) +\n  scale_y_continuous(labels = label_comma()) +\n\n  scale_color_manual(\n    values = c(\n      \"10 Most Rent Burdened\" = \"red\",\n      \"10 Least Rent Burdened\" = \"green4\",\n      \"Other\" = \"gray70\"\n    )\n  ) +\n  \n  labs(\n    title = paste0(\"Highest vs. Lowest Rent Burden Metros (\", latest_year, \")\"),\n    subtitle = \"\",\n    x = \"Average Household Income ($)\",\n    y = \"Rent Burden Index\",\n    color = \"\"\n  ) +\n  \n  theme_minimal(base_size = 14) +\n  theme(\n    plot.title = element_text(face = \"bold\", color = \"black\", hjust = 0.5),\n    plot.subtitle = element_text(hjust = 0.5),\n    legend.position = \"bottom\",\n    legend.direction = \"horizontal\",\n    legend.box = \"horizontal\",\n    legend.spacing.x = unit(0.5, \"cm\"),\n    legend.title = element_text(size = 12, face = \"bold\"),\n    legend.text = element_text(size = 12)\n  )\n\n\n```\n## Housing Growth\n\nWe will now identify the most building friendly metro areas using two methods.\n\nFirst, we will look at the instantaneous housing growth by measuring how much they build right now given their size. To do this we will measure annual permits per 10,000 people. 2014 is our baseline for the intensity index.\n\nSecond, we evaluate whether metros are building enough given how fast they are growing. To do this, we measure each metro’s population growth over a fixed 5-year window. Then we relate current annual permits to that 5-year population increase, giving us permits per new resident. We again use the 2014 national mean as a baseline to form the growth index since it is the first 5 year window in our data.\n\n\nFinally, we combine these two pieces into a composite measure that reflects both how much a metro builds per capita and how well it keeps up with its own population growth. This composite score helps us identify metros that consistently build at strong levels across both dimensions.\n\n\n\n\n```{r results='asis'}\n\n# task 5 \n#join together the POPULATION and PERMITS tables. Using this data, construct a suitable measure of housing growth: that is, how many new housing units are permitted in a CBSA, relative to both the current number of residents and the overall population growth of that CBSA. Because this metric takes into account growth patterns, it should depend on a fixed lookback-window of 5 years used to estimate population growth.\n\n# Housing Growth\n\nlibrary(dplyr)\nlibrary(DT)\nlibrary(scales)\nlibrary(stringr)\n\n# helper to shorten metro names to first three words\nshort_name3 <- function(x) {\n  sapply(strsplit(x, \" \"), function(y) paste(head(y, 3), collapse = \" \"))\n}\n\n# join POPULATION + PERMITS\npop_housing <- POPULATION %>%\n  select(GEOID, NAME, year, population) %>%\n  left_join(\n    PERMITS %>%\n      rename(\n        GEOID = CBSA,\n        permits = new_housing_units_permitted\n      ),\n    by = c(\"GEOID\", \"year\")\n  )\n\n# compute 5 year population growth within each metro\npop_housing <- pop_housing %>%\n  arrange(GEOID, year) %>%\n  group_by(GEOID) %>%\n  mutate(\n    pop_lag5 = lag(population, 5),\n    pop_growth_5yr = population - pop_lag5\n  ) %>%\n  ungroup()\n\n# instantaneous measure permits per 10k residents and index baseline 2014 mean = 100\npop_housing <- pop_housing %>%\n  mutate(permits_per_10k = (permits / population) * 10000)\n\nbaseline_intensity_2014 <- pop_housing %>%\n  filter(year == 2014) %>%\n  summarise(mean_10k = mean(permits_per_10k, na.rm = TRUE)) %>%\n  pull(mean_10k)\n\npop_housing <- pop_housing %>%\n  mutate(intensity_index = (permits_per_10k / baseline_intensity_2014) * 100)\n\n# rate based measure permits relative to 5 year population growth and index baseline 2014 mean = 100\npop_housing <- pop_housing %>%\n  mutate(permits_per_growth = permits / pop_growth_5yr)\n\nbaseline_growth_2014 <- pop_housing %>%\n  filter(year == 2014) %>%\n  summarise(mean_growth = mean(permits_per_growth, na.rm = TRUE)) %>%\n  pull(mean_growth)\n\npop_housing <- pop_housing %>%\n  mutate(growth_index = (permits_per_growth / baseline_growth_2014) * 100)\n\n# composite score no weights simple average of the two indices\npop_housing <- pop_housing %>%\n  mutate(composite_score = (intensity_index + growth_index) / 2)\n\n# choose most recent year available for tables\nlatest_year <- max(pop_housing$year, na.rm = TRUE)\n\n# build instantaneous table top 10 and bottom 10 by permits per 10k in latest year\ninst_tbl <- pop_housing %>%\n  filter(year == latest_year, is.finite(permits_per_10k)) %>%\n  mutate(\n    Category = if_else(intensity_index >= 100, \"HIGH\", \"LOW\"),\n    `Metro Area` = short_name3(NAME)\n  ) %>%\n  select(\n    Category,\n    `Metro Area`,\n    Population = population,\n    `Annual Permits` = permits,\n    `Permits per 10k` = permits_per_10k,\n    `Intensity Index` = intensity_index\n  )\n\ninst_high <- inst_tbl %>%\n  filter(Category == \"HIGH\") %>%\n  arrange(desc(`Permits per 10k`)) %>%\n  slice_head(n = 10)\n\ninst_low <- inst_tbl %>%\n  filter(Category == \"LOW\") %>%\n  arrange(`Permits per 10k`) %>%\n  slice_head(n = 10)\n\ninst_final <- bind_rows(inst_high, inst_low)\n\ndatatable(\n  inst_final %>%\n    mutate(\n      Population = comma(Population),\n      `Annual Permits` = comma(`Annual Permits`),\n      `Permits per 10k` = round(`Permits per 10k`, 2),\n      `Intensity Index` = round(`Intensity Index`, 1)\n    ),\n  rownames = FALSE,\n  options = list(\n    dom = 't',\n    pageLength = 20,\n    autoWidth = TRUE\n  ),\n   caption = htmltools::tags$caption(\n    style = 'caption-side: top; text-align: left; margin-bottom: 10px;',\n    htmltools::tags$div(\n      style = 'font-size: 16pt; font-weight: bold;',\n      paste0(\"Permits Per Capita In \", latest_year)\n    )\n  )\n)\n\n# build growth adjusted table top 10 and bottom 10 by permits per growth in latest year\ngrowth_tbl <- pop_housing %>%\n  filter(year == latest_year, is.finite(permits_per_growth)) %>%\n  mutate(\n    Category = if_else(growth_index >= 100, \"HIGH\", \"LOW\"),\n    `Metro Area` = short_name3(NAME)\n  ) %>%\n  select(\n    Category,\n    `Metro Area`,\n    `5 Year Population Growth` = pop_growth_5yr,\n    `Annual Permits` = permits,\n    `Permits per Growth` = permits_per_growth,\n    `Growth Index` = growth_index\n  )\n\ngrowth_high <- growth_tbl %>%\n  filter(Category == \"HIGH\") %>%\n  arrange(desc(`Permits per Growth`)) %>%\n  slice_head(n = 10)\n\ngrowth_low <- growth_tbl %>%\n  filter(Category == \"LOW\") %>%\n  arrange(`Permits per Growth`) %>%\n  slice_head(n = 10)\n\ngrowth_final <- bind_rows(growth_high, growth_low)\n\ndatatable(\n  growth_final %>%\n    mutate(\n      `5 Year Population Growth` = comma(`5 Year Population Growth`),\n      `Annual Permits` = comma(`Annual Permits`),\n      `Permits per Growth` = round(`Permits per Growth`, 3),\n      `Growth Index` = round(`Growth Index`, 1)\n    ),\n  rownames = FALSE,\n  options = list(\n    dom = 't',\n    pageLength = 20,\n    autoWidth = TRUE\n  ),\n  caption = htmltools::tags$caption(\n    style = 'caption-side: top; text-align: left; margin-bottom: 10px;',\n    htmltools::tags$div(\n      style = 'font-size: 16pt; font-weight: bold;',\n      paste0(\"Growth Adjusted Housing Supply In \", latest_year)\n    )\n  )\n)\n\n# build composite table top 10 and bottom 10 by composite score\ncomp_tbl <- pop_housing %>%\n  filter(year == latest_year, is.finite(composite_score)) %>%\n  mutate(\n    `Metro Area` = short_name3(NAME)\n  ) %>%\n  select(\n    `Metro Area`,\n    Population = population,\n    `Annual Permits` = permits,\n    `Permits per 10k` = permits_per_10k,\n    `Intensity Index` = intensity_index,\n    `Growth Index` = growth_index,\n    `Composite Score` = composite_score\n  )\n\ncomp_high <- comp_tbl %>%\n  arrange(desc(`Composite Score`)) %>%\n  slice_head(n = 10) %>%\n  mutate(Category = \"HIGHEST COMPOSITE\")\n\ncomp_low <- comp_tbl %>%\n  arrange(`Composite Score`) %>%\n  slice_head(n = 10) %>%\n  mutate(Category = \"LOWEST COMPOSITE\")\n\ncomp_final <- bind_rows(comp_high, comp_low) %>%\n  relocate(Category, .before = 1)\n\ndatatable(\n  comp_final %>%\n    mutate(\n      Population = comma(Population),\n      `Annual Permits` = comma(`Annual Permits`),\n      `Permits per 10k` = round(`Permits per 10k`, 2),\n      `Intensity Index` = round(`Intensity Index`, 1),\n      `Growth Index` = round(`Growth Index`, 1),\n      `Composite Score` = round(`Composite Score`, 1)\n    ),\n  rownames = FALSE,\n  options = list(\n    dom = 't',\n    pageLength = 20,\n    autoWidth = TRUE\n  ),\n  caption = htmltools::tags$caption(\n    style = 'caption-side: top; text-align: left; margin-bottom: 10px;',\n    htmltools::tags$div(\n      style = 'font-size: 16pt; font-weight: bold;',\n      paste0(\"Composite Housing Growth Score In \", latest_year)\n    )\n  )\n)\n\n```\n\n## Visualizations For Identifying YIMBY Cities\n\n```{r}\n# Task 6: Visualizations\n# We relate rent burden change, population growth, and housing growth\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(tidyr)\n\n# Compute rent burden change\nrent_change <- rent_burden %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, year, rent_burden_index) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = rent_burden_index,\n    names_prefix = \"rb_\"\n  ) %>%\n  mutate(rent_change = rb_2023 - rb_2009)\n\n# Compute population change 2009–2023\npop_change <- POPULATION %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, population, year) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = population,\n    names_prefix = \"pop_\"\n  ) %>%\n  mutate(pop_change = pop_2023 - pop_2009)\n\n# Build task 6 dataset\ntask6 <- pop_housing %>%\n  filter(year == 2023) %>%\n  select(GEOID, permits_per_10k, intensity_index, pop_growth_5yr, growth_index) %>%\n  left_join(POPULATION %>% select(GEOID, NAME), by = \"GEOID\") %>%\n  left_join(rent_change, by = \"GEOID\") %>%\n  left_join(pop_change, by = \"GEOID\") %>%\n  mutate(\n    yimby_flag = if_else(\n      rb_2009 > median(rb_2009, na.rm = TRUE) &\n      rent_change < 0 &\n      pop_change > 0 &\n      intensity_index > median(intensity_index, na.rm = TRUE) &\n      growth_index > median(growth_index, na.rm = TRUE),\n      \"YIMBY Candidate\", \"Other\"\n    )\n  )\n\n# Color palette\ncbsa_palette <- c(\n  \"YIMBY Candidate\" = \"#1b9e77\",\n  \"Other\" = \"#7570b3\"\n)\n\n```\n\n\nThe following plot examines how changes in rent burden from 2009 to 2023 relate to per-capita housing production in 2023, measured as permits per 10,000 residents. We created this plot to see which metros, if any, build more housing on a per-resident basis and experience smaller increases in rent burden over time.\n\nThe “YIMBY Candidate” metros are those that experienced above-median housing production (as measured by the intensity index) and also saw rent-burden improvement. \n\n```{r}\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(tidyr)\n\n# Compute rent burden change 2009 → 2023 \nrent_change <- rent_burden %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, year, rent_burden_index) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = rent_burden_index,\n    names_prefix = \"rb_\"\n  ) %>%\n  mutate(rent_change = rb_2023 - rb_2009)\n\n# compute population change 2009 → 2023 \npop_change <- POPULATION %>%\n  filter(year %in% c(2009, 2023)) %>%\n  select(GEOID, population, year) %>%\n  pivot_wider(\n    names_from = year,\n    values_from = population,\n    names_prefix = \"pop_\"\n  ) %>%\n  mutate(pop_change = pop_2023 - pop_2009)\n\n# data\ntask6 <- pop_housing %>%\n  filter(year == 2023) %>%\n  select(GEOID, permits_per_10k, intensity_index, pop_growth_5yr, growth_index) %>%\n  left_join(POPULATION %>% select(GEOID, NAME), by = \"GEOID\") %>%\n  left_join(rent_change, by = \"GEOID\") %>%\n  left_join(pop_change, by = \"GEOID\") %>%\n  mutate(\n    yimby_flag = if_else(\n      rb_2009 > median(rb_2009, na.rm = TRUE) &\n      rent_change < 0 &\n      pop_change > 0 &\n      intensity_index > median(intensity_index, na.rm = TRUE) &\n      growth_index > median(growth_index, na.rm = TRUE),\n      \"YIMBY Candidate\",\n      \"Other\"\n    )\n  )\n\n# Remove rows with missing values for the plotted vars \nplot_data <- task6 %>%\n  filter(\n    is.finite(rent_change),\n    is.finite(permits_per_10k)\n  )\n\n# plot\nggplot(plot_data, aes(x = rent_change, y = permits_per_10k, color = yimby_flag)) +\n  geom_point(size = 3, alpha = 0.85) +\n  scale_color_manual(values = c(\"YIMBY Candidate\" = \"#1b9e77\", \"Other\" = \"#7570b3\")) +\n  labs(\n    title = \"Rent Burden  vs  Housing Production\",\n    x = \"Change in Rent Burden (Index Points)\",\n    y = \"Permits per 10,000 Residents\",\n    color = \"\"\n  ) +\ntheme_minimal(base_size = 15) +\ntheme(\n    legend.position = \"bottom\",\n    plot.title = element_text(size = 20, face = \"bold\", hjust = 0.5),\n    plot.subtitle = element_text(size = 14, hjust = 0.5)\n)\n\n```\nThe following  two small-multiple plots take a closer look at the six metros that emerged as the strongest YIMBY candidates: Rocky Mount NC, Harrisonburg VA, Yuma AZ, Winchester VA WV, Gulfport Biloxi MS, and Laredo TX. In the first plot, we can see that all six metros experienced a decline in rent burden over time, which is exactly what we would hope to see in places that are building enough housing to keep pressure off prices. \n\nThe second plot shows how much these areas have been building relative to their size, and for most of them the story is consistent. Rocky Mount, Harrisonburg, Yuma, Winchester, and Laredo all exhibit strong per-capita housing production, reinforcing why they score highly as YIMBY metros. \n\nGulfport Biloxi is the one partial outlier: it did reduce rent burden, but its permitting activity does not increase nearly as much as the others. This could mean its affordability gains are driven more by slower demand or population changes than by sustained housing growth.\n\n```{r}\n#Plot 2a\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\n\n# Ensure one row per CBSA\ntask6_unique <- task6 %>% distinct(GEOID, .keep_all = TRUE)\n\n# 2. Filter metros meeting BOTH criteria\n# - rent burden decreased more than typical\n# - housing production per capita higher than typical\n\nyimby_filtered <- task6_unique %>%\n  filter(\n    is.finite(rent_change),\n    is.finite(permits_per_10k)\n  ) %>%\n  filter(\n    rent_change < median(rent_change, na.rm = TRUE),\n    permits_per_10k > median(permits_per_10k, na.rm = TRUE)\n  )\n\n# 3. Pick the TOP 6 best performers:\n#    - most rent burden decrease (more negative is better)\n#    - more permits per 10k secondarily\n\ntop6 <- yimby_filtered %>%\n  arrange(rent_change, desc(permits_per_10k)) %>%\n  slice_head(n = 6) %>%\n  pull(NAME)\n\n# 4. Prepare rent burden time series for these 6 metros\n\nshort_name <- function(x) {\n  sapply(strsplit(x, \" \"), function(y) paste(head(y, 2), collapse = \" \"))\n}\n\nyimby_rent_trends <- rent_burden %>%\n  filter(NAME %in% top6) %>%\n  mutate(short = short_name(NAME))\n\n# 5. Plot 2A — Rent Burden Trends\n\nggplot(yimby_rent_trends, aes(x = year, y = rent_burden_index)) +\n  geom_line(color = \"#1b9e77\", linewidth = 1) +\n  geom_point(color = \"#1b9e77\", size = 2) +\n  facet_wrap(~ short, ncol = 3, scales = \"free_y\") +\n  scale_y_continuous(labels = label_comma()) +\n  labs(\n    title = \"Rent Burden Trends for Top 6 YIMBY Metros\",\n    subtitle = \"Metros that both reduced rent burden and built more housing per capita\",\n    x = \"Year\",\n    y = \"Rent Burden Index (2009 = 100)\"\n  ) +\n  theme_minimal(base_size = 16) +\n  theme(\n    strip.text = element_text(size = 9, face = \"bold\"),\n    plot.title = element_text(face = \"bold\", size = 20, hjust = 0.5),\n    plot.subtitle = element_text(size = 14, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    axis.text.y = element_text(size = 10),\n    panel.spacing = unit(1.2, \"lines\")\n  )\n\n#2b plot\nlibrary(stringr)\n\n# (Optional: If you prefer YOUR manually chosen 6)\n# top6 <- c(\n#   \"Rocky Mount, NC Metro Area\",\n#   \"Harrisonburg, VA Metro Area\",\n#   \"Yuma, AZ Metro Area\",\n#   \"Winchester, VA-WV Metro Area\",\n#   \"Gulfport-Biloxi, MS Metro Area\",\n#   \"Laredo, TX Metro Area\"\n# )\n\nyimby_housing_trends <- pop_housing %>%\n  filter(NAME %in% top6) %>%\n  mutate(short = short_name(NAME))\n\nggplot(yimby_housing_trends, aes(x = year, y = permits_per_10k)) +\n  geom_line(color = \"#1b9e77\", linewidth = 1) +\n  geom_point(color = \"#1b9e77\", size = 2) +\n  facet_wrap(~ short, ncol = 3, scales = \"free_y\") +\n  scale_y_continuous(labels = label_comma()) +\n  labs(\n    title = \"Housing Production Over Time\",\n    subtitle = \"Top 6 YIMBY Candidate Metros Identified in Scatterplot\",\n    x = \"Year\",\n    y = \"Permits per 10,000 Residents\"\n  ) +\n  theme_minimal(base_size = 16) +\n  theme(\n    strip.text = element_text(size = 9, face = \"bold\"),\n    plot.title = element_text(face = \"bold\", size = 20, hjust = 0.5),\n    plot.subtitle = element_text(size = 14, hjust = 0.5),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    panel.spacing = unit(1.2, \"lines\")\n  )\n```\n```{r}\n#data for Policy breif\n# Find start and end values for Rocky Mount\nrb_rm <- rent_burden %>%\n  filter(NAME == \"Rocky Mount, NC Metro Area\") %>%\n  arrange(year)\n\nrb_rm_start <- rb_rm$rent_burden_index[1]\nrb_rm_end   <- rb_rm$rent_burden_index[nrow(rb_rm)]\n\nrent_burden_pct_change <- (rb_rm_end - rb_rm_start) / rb_rm_start * 100\nrent_burden_pct_change\n\n# Compute Rocky Mount housing production % change using permits_per_10k\n\nhg_rm <- pop_housing %>%\n  filter(NAME == \"Rocky Mount, NC Metro Area\") %>%\n  arrange(year)\n\nhg_rm_start <- hg_rm$permits_per_10k[1]\nhg_rm_end   <- hg_rm$permits_per_10k[nrow(hg_rm)]\n\nhousing_growth_pct_change <- (hg_rm_end - hg_rm_start) / hg_rm_start * 100\nhousing_growth_pct_change\n\n```\n\n# Policy Brief\n\n## Backyards For All Bill: Why All Americans Deserve Affordable Housing\n\n\nAmerica’s housing shortage continues to push rents upward in many major metropolitan cities, New York being one of the most dire examples, with only around 1% of housing units are vacant. As a result, many working class people are either getting pushed out of their cities, or suffering a loss in standard of living year over year. With general inflation running rampant in recent years, it is imperative that a change be made to bring releif to everyday Americans. \n\nThis proposal establishes a competitive federal program that rewards cities for modernizing zoning, approving homes more efficiently, and reducing rent burdens. The goal is simple: accelerate homebuilding in the places where Americans already live, work, and want to stay.\n\n\n**Primary sponsor**: \n\nA congressional representative from Rocky Mount, NC Metro Area — one of the clearest YIMBY successes in our analysis. Rocky Mount permitted housing at strong per-capita levels and saw a meaningful decline in rent burden over time. Rocky Mount is an ideal sponsor becasue they were able to implement a 28% increase in housing growth which led to a 20% decrease in rent burden for their population.\n\n**Co-sponsor**: \n\nA congressional representative from New York City, NY Metro Area — a high-rent, slower-to-build region where the affordability crisis is sharpest and federal incentives would have the biggest impact. \n\n**Support groups:** \n\nMobilize Nurses and other healthcare workers (SEIU, National Nurses United).\n\nBoth Rocky Mount and NYC have substantial healthcare workforces. In cities that permit more housing, rent burdens fall, leaving nurses with more disposable income and reducing turnover for hospitals and clinics. This stabilizes nurse staffing, which is a top concern for these unions.\n\nTeachers and school staff (AFT, NEA).\nEducators make up a large, locally rooted voting bloc in both metros. Lower rent burden helps teachers stay in their districts instead of commuting long distances or leaving the profession. Currently, 33% of teachers in NYC live outside of the city due to high rent prices (Independent Budget Office 2019). \n\n**What the program funds:**\n\n- Performance-based grants for cities that legalize more homes near jobs and transit, digitize their permitting processes, and demonstrate progress in lowering rent burden.\n\n- Technical assistance including model zoning codes and pre-approved residential plans.\n\n**How we measure success:**\n\n- Rent-burden index: We compare typical rent to typical household income and scale everything so 2009 = 100. When a city’s index falls below 100 over time, residents are spending a smaller share of their income on rent, this is a clear sign of improved affordability.\n\n- Housing-growth metrics: Permits per 10,000 residents: A per-capita measure of how much a city is building today, allowing for fair comparison across metros.\n\n- Growth-adjusted index: Permits relative to each city’s five-year population growth, answering whether a city is building enough to keep up with demand.\n\n**Why NewYorkers Will all Benefit:**\n\nNew York is known as \"the city that never sleeps\" however, anyone who lives there will tell you that this saying hardly hold true today. Most shops, restaurants and cafes are closed by 9 or 10pm even on weekends. What caused this? For most of its history, New York was an industrial city. Factory workers kept long, irregular hours and the businesses around them stayed open late to match their schedules. After that era ended, the city became a hub for artists, who also tended to live and work on nontraditional hours, keeping New York’s late night culture alive.\n\nToday, Manhattan has undergone a wave of corporate consolidation. Large companies have bought up much of the real estate, and as prices rose, artists and other creative workers were pushed to the outer boroughs while corporate employees with more conventional schedules replaced them. Neighborhoods in Brooklyn and Queens still hold onto pieces of the old nightlife energy, but in Manhattan it has mostly faded.\n  \nMaking housing more affordable in Manhattan by building more homes would help reverse this shift. If younger people and artists could actually afford to live there again, the city could begin to regain some of the vibrancy that once defined it. This would not only improve the quality of life for Gen Z and Millennials, but it would also boost the broader city economy. The nightlife sector alone contributes about 35 billion dollars to New York City’s economy, and restoring that culture would help strengthen the city as a whole (Mayor’s Office of Media and Entertainment, 2019). \n\n\nTogether, these measures reward cities that both build more housing and reduce rent pressure. \n\n**Citations**\n\nMayor’s Office of Media and Entertainment. (2019). NYC Nightlife Economic Impact Report. Retrieved from https://www.nyc.gov/assets/mome/pdf/NYC_Nightlife_Economic_Impact_Report_2019_digital.pdf\n\nNew York City Independent Budget Office. (2019). Where Do NYC’s Teachers and Principals Live Compared With Where They Work? Retrieved from https://www.ibo.nyc.ny.us/iboreports/printnycbtn19.pdf"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"mp02.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.8.23","editor":{"mode":"source"},"theme":"morph","title":"STA 9750 — Mini-Project 02","author":"Maham Hassan","date":"October 30, 2025"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}